---
layout: default
title: Charity graph - multi-root BFS & taxpayer totals
---

<!-- jQuery for convenience -->
<script src="jquery.min.js"></script>

<!-- Viz.js (core + full render) -->
<script src="viz.js"></script>
<script src="full.render.js"></script>

<!-- svg-pan-zoom for panning/zooming the resulting SVG -->
<script src="svg-pan-zoom.min.js"></script>

<!-- JSZip for reading the zipped CSVs -->
<script src="jszip.min.js"></script>

<!-- Papa Parse for CSV parsing -->
<script src="papaparse.min.js"></script>

<style>
  #activeEINs, #activeFilters {
    display: flex;
    flex-wrap: wrap;
    gap: 0.5em;
  }

  #graph-container {
    overflow: hidden; /* Hide scrollbars */
  }
</style>

<div id="topbar" class="">
  <div id="explanation">
    <h1 class="mb-1">Charity graph</h1>
    <!-- If custom_graph is present, we show "title" or "Displaying exact graph." below -->
    <p id="instructions" class="opacity-80 mb-0 text-[15px]">
      <!-- Will be dynamically set in parseQueryParams() -->
    </p>
    <script>
      const urlParams = new URLSearchParams(window.location.search);
      const returnUrl = urlParams.get('return_url');
      if (returnUrl) {
        document.write(`<div class="mt-1 mb-2"><button class="frameless" onclick="window.location.href='${returnUrl}'">&larr; Back to officer search</button></div>`);
      }
    </script>
    
    <!-- "How it works" toggle is BFS-only -->
    <button class="frameless mb-2 text-base bfs-only" id="howItWorksBtn">How it works</button>
    <div class="h-[0px] overflow-hidden transition-all duration-200 bfs-only" id="howItWorksList">
      <div class="p-4 border border-gray-200 rounded-md bg-white">
        <h3 class="mt-0">How it works</h3>
        <ol class="!list-decimal space-y-1 text-sm pl-4">
          <li>We filter charities by user-specified EINs + any keywords. EINs are always included, everything else must match at least one keyword <em>unless</em> no keywords are set (then all are included).</li>
          <li>We pick the BFS root from the largest-<code>receipt_amt</code> EIN (if any exist), otherwise the largest from the filtered set. If that BFS yields fewer than 5 nodes, we pick the next-largest unvisited charity in the filtered set, BFS again, and so on, until the subgraph has 5 or more nodes or we run out.</li>
          <li>We always include all user-specified EINs plus direct edges among them. Node labels highlight <strong>Taxpayer Funds Received</strong> from <code>govt_amt</code>, and we sum that for the final subgraph.</li>
        </ol>
        <h3 class="">How to use</h3>
        <ol class="!list-decimal space-y-1 text-sm pl-4">
          <li>By default, the graph will zoom into the starting point where the money flow begins</li>
          <li>Search for organizations in the graph by typing a name in the search bar</li>
          <li>Click a connecting line (or grant amount) to zoom to its source and destination</li>
          <li>Click and drag to explore the connections on the canvas</li>
          <li>Use your mouse's scroll function to zoom in and out</li>
        </ol>
      </div>
    </div>
  </div>

  <!-- BFS controls are BFS-only -->
  <div id="controls" class="mt-2 mb-4 flex flex-col @xl:items-start @xl:justify-between @xl:flex-row gap-4 bfs-only">
    <!-- EIN Input & Add Button -->
    <div class="relative flex flex-col gap-2 max-w-lg">
      {% include input.html 
        label="Add EIN(s)" 
        id="einInput" 
        placeholder="XX-XXXXXXX or 9 digits" 
        buttonLabel="Add EIN" 
        buttonId="addEinBtn" 
        actions="<button id='clearEINsBtn' class='frameless'>Clear EINs</button>"
      %}

      <div id="activeEINs"></div>
    </div>

    <div class="relative flex flex-col gap-2 max-w-lg">
      {% include input.html 
        label="Add keyword" 
        id="keywordInput" 
        placeholder="Keyword or phrase..." 
        buttonLabel="Add" 
        buttonId="addFilterBtn"
        actions="<button id='clearFiltersBtn' class='frameless'>Clear keywords</button>"
      %}

      <div id="activeFilters"></div>
    </div>

    <div class="flex-1 text-right flex flex-row-reverse md:flex-col items-end justify-between md:justify-end gap-1 md:self-end">
      <!-- <button id="generateBtn">Generate Graph</button> -->
      <button id="downloadBtn" class="frameless" style="display: none;">
        <span class="flex items-center gap-1 text-sm text-gray-500 font-semibold">
          <img src="/assets/images/download.svg" class="size-5" alt="Download SVG">
          Download SVG
        </span>
      </button>
      <div id="status" class=""></div>
    </div>
  </div>
</div>

<div id="excluded-info" class="-mx-4 md:mx-0 mb-4 px-3 pt-3 pb-2 flex gap-4 md:gap-8 md:rounded border-y md:border-x border-gray-200 bg-white" style="display: none;">
  {% include stat.html label="501(c)(3)s <em>not</em> displayed" valueId="excluded501" %}
  {% include stat.html label="Grants <em>not</em> displayed" valueId="excludedGrants" %}
  {% include stat.html label="<strong class='font-semibold'>Taxpayer total in subgraph</strong>" labelColor="text-red opacity-100" valueId="taxpayerTotal" %}
</div>

<div class="relative flex-1 -mx-4 md:mx-0 min-h-[75vh]">

  <!-- Search -->
  <div class="absolute top-4 left-4 md:left-[initial] right-4 z-10">
    <div class="relative">
      <input 
        type="text" 
        id="searchInput"
        class="w-full md:w-64 px-2 py-2 md:py-1 text-sm border border-gray-300 rounded-sm shadow-sm focus:ring-2 focus:ring-blue-500 focus:border-transparent"
        placeholder="Search graph..."
        autocomplete="off"
      >
      <button 
        id="clearSearch" 
        class="absolute right-2 top-1/2 -translate-y-1/2 min-w-0 p-1 aspect-square items-center justify-center rounded-full bg-gray-100 hover:bg-gray-200 hidden"
        aria-label="Clear search"
      >
        <svg class="w-4 h-4 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
        </svg>
      </button>
      <div id="searchResults" class="absolute w-full mt-1 bg-white border border-gray-200 rounded-md shadow-lg hidden max-h-[50vh] overflow-y-auto">
        <!-- Results will be populated here -->
      </div>
    </div>
  </div>

  <!-- Legend -->
  <div class="absolute bottom-4 left-4 z-10 bg-white p-3 rounded-md shadow-md border border-gray-200 flex flex-col md:flex-row gap-2 md:gap-4">
    <div class="flex items-center gap-2">
      <div class="w-4 h-4 bg-[#FEE2E2] rounded-sm border-2 border-[#DC2626]"></div>
      <span class="text-[13px]">ðŸš¨ High taxpayer funds (>$10M)</span>
    </div>
    <div class="flex items-center gap-2">
      <div class="w-4 h-4 bg-[#FEF3C7] rounded-sm border-2 border-[#D97706]"></div>
      <span class="text-[13px]">Medium taxpayer funds ($1M-$10M)</span>
    </div>
    <div class="flex items-center gap-2">
      <div class="w-4 h-4 bg-[#F3F4F6] rounded-sm border-2 border-[#94A3B8]"></div>
      <span class="text-[13px]">Low/No taxpayer funds</span>
    </div>
  </div>

  <!-- Zoom Controls -->
  <div class="absolute bottom-4 right-4 z-10 flex flex-col gap-1">
    <button id="zoomIn" class="p-2 rounded min-w-0 mr-0 bg-black/60 hover:bg-black">
      <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6v6m0 0v6m0-6h6m-6 0H6"/>
      </svg>
    </button>
    <button id="zoomOut" class="p-2 rounded min-w-0 mr-0 bg-black/60 hover:bg-black">
      <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M20 12H4"/>
      </svg>
    </button>
    <button id="zoomFit" class="p-2 rounded min-w-0 mr-0 bg-black/60 hover:bg-black">
      <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 8V4m0 0h4M4 4l5 5m11-5V4m0 0h-4m4 0l-5 5M4 16v4m0 0h4m-4 0l5-5m11 5v-4m0 4h-4m4 0l-5-5"/>
      </svg>
    </button>
  </div>

  <!-- Graph Container -->
  <div id="graph-container" class="absolute inset-0 border-y md:border-x border-gray-200 md:rounded bg-white">
    <svg id="graph"></svg>
  </div>
  
  <!-- Update the loading div structure -->
  <div id="loading" class="absolute inset-0 flex flex-col pt-5 bg-white z-30">
    <div class="text-center">
      <svg class="animate-spin h-8 w-8 text-navy mx-auto mb-4" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
        <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
        <path fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4z"></path>
      </svg>
      <div id="loading-text" class="text-lg font-semibold text-navy mb-4">Loading graph...</div>
      <div id="loading-charities" class="text-gray-600 max-w-md mx-auto text-center max-h-[50vh] overflow-y-auto px-4">
        <!-- Charity names will be added here -->
      </div>
    </div>
  </div>
</div>

<!-- Add D3.js -->
<script src="https://d3js.org/d3.v7.min.js"></script>

<script>
  // Add with other global variables at the top
  const BFS_CAP = 20;
  const cornerPadding = 10; // Minimum distance from corners for line connections

  // Full data from CSV
  let charities = {};             // EIN -> { name, receipt_amt, govt_amt, contrib_amt, grant_amt }
  let edgeAccumulator = {};       // "filer~grantee" -> totalGrant
  let totalCharitiesCount = 0;    // total charities read
  let totalGrantsCount = 0;       // total edges read from CSV

  // Filter state
  let activeEINs = [];
  let activeKeywords = [];

  // BFS / data-ready
  let dataReady = false;
  let panZoomInstance = null;

  // Custom graph state
  let customGraphEdges = null;  // array of objects { filer, grantee, amt }
  let customTitle = null;       // optional custom title from the query param

  // Add this with other global variables at the top
  let simulation = null;
  let nodeElements = null;
  let zoom = null;
  let selectedSearchIndex = 0; // Track selected search result

  // Add near the top of the script, before any functions
  let width, height;

  // Then update these when creating the SVG (around line 100)
  const container = document.getElementById('graph-container');
  const svg = d3.select('#graph')
    .attr('width', '100%')
    .attr('height', '100%');

  // Get actual dimensions from container
  width = container.clientWidth;
  height = container.clientHeight;

  // Create zoom behavior
  zoom = d3.zoom()
    .scaleExtent([0.1, 2])
    .on('zoom', (event) => {
      g.attr('transform', event.transform);
    });

  svg.call(zoom);

  // Create the main group that will be transformed
  const g = svg.append('g');

  // Add these helper functions at the top
  function getConnectionsToSide(edges, nodeId, side) {
    // side can be 'top', 'bottom', 'left', 'right'
    return edges.filter(edge => {
      if (side === 'top' || side === 'bottom') {
        // For connections from the top or bottom of the node
        if ((edge.source.id === nodeId && (side === 'top' || side === 'bottom')) ||
            (edge.target.id === nodeId && (side === 'top' || side === 'bottom'))) {
          
          // Determine if this is a source or target connection
          const isSource = edge.source.id === nodeId;
          const thisNode = isSource ? edge.source : edge.target;
          const otherNode = isSource ? edge.target : edge.source;
          
          // For top connections, the other node should be above this node
          if (side === 'top') {
            return otherNode.y < thisNode.y;
          } 
          // For bottom connections, the other node should be below this node
          else {
            return otherNode.y > thisNode.y;
          }
        }
        return false;
      } 
      else if (side === 'left' || side === 'right') {
        // For connections from the left or right of the node
        if ((edge.source.id === nodeId && (side === 'left' || side === 'right')) ||
            (edge.target.id === nodeId && (side === 'left' || side === 'right'))) {
          
          // Determine if this is a source or target connection
          const isSource = edge.source.id === nodeId;
          const thisNode = isSource ? edge.source : edge.target;
          const otherNode = isSource ? edge.target : edge.source;
          
          // For left connections, the other node should be to the left of this node
          if (side === 'left') {
            return otherNode.x < thisNode.x;
          } 
          // For right connections, the other node should be to the right of this node
          else {
            return otherNode.x > thisNode.x;
          }
        }
        return false;
      }
      
      // Default case should not happen
      return false;
    });
  }

  $(document).ready(function() {

    // Parse query params first
    parseQueryParams();

    // Load data once
    loadData().then(() => {
      dataReady = true;
      $('#status').text('Data loaded.').css('color', 'black');
      // Generate graph right away (which will respect BFS or custom logic)
      generateGraph();
    }).catch(err => {
      console.error(err);
      $('#status').text('Failed to load data.').css('color', 'red');
    });

    // EIN handling
    $('#addEinBtn').on('click', addEINFromInput);
    $('#einInput').on('keypress', e => {
      if (e.key === 'Enter') addEINFromInput();
    });
    $('#clearEINsBtn').on('click', () => {
      activeEINs = [];
      renderActiveEINs();
      updateQueryParams();
      generateGraph();
    });

    // Keywords
    $('#addFilterBtn').on('click', addKeywordFromInput);
    $('#keywordInput').on('keypress', e => {
      if (e.key === 'Enter') addKeywordFromInput();
    });
    $('#clearFiltersBtn').on('click', () => {
      activeKeywords = [];
      renderActiveKeywords();
      updateQueryParams();
      generateGraph();
    });

    // Download SVG
    $('#downloadBtn').on('click', downloadSVG);

    // Expand/collapse "How it works" (BFS-only)
    $('#howItWorksBtn').on('click', function() {
      const $list = $('#howItWorksList');
      const $btn = $(this);

      if ($list.height() === 0) {
        // Expand
        $list.css('height', 'auto');
        const autoHeight = $list.height();
        $list.height(0);
        $list.height(autoHeight);
        $btn.text('Hide details');
      } else {
        // Collapse
        $list.height(0);
        $btn.text('How it works');
      }
    });

    // Add search handlers after graph is generated
    const searchInput = document.getElementById('searchInput');
    const searchResults = document.getElementById('searchResults');
    const clearButton = document.getElementById('clearSearch');
    
    // Remove any existing listeners
    const newSearchInput = searchInput.cloneNode(true);
    const newSearchResults = searchResults.cloneNode(true);
    const newClearButton = clearButton.cloneNode(true);
    
    searchInput.parentNode.replaceChild(newSearchInput, searchInput);
    searchResults.parentNode.replaceChild(newSearchResults, searchResults);
    clearButton.parentNode.replaceChild(newClearButton, clearButton);

    // Add new listeners
    newSearchInput.addEventListener('input', handleSearch);
    newSearchInput.addEventListener('focus', handleSearchFocus); // New handler
    newSearchInput.addEventListener('blur', handleSearchBlur);
    newSearchResults.addEventListener('click', handleSearchClick);
    newSearchInput.addEventListener('keydown', handleSearchKeydown);

    // Add clear button handler
    newClearButton.addEventListener('click', () => {
      newSearchInput.value = '';
      newSearchInput.focus();
      handleSearch({ target: newSearchInput });
    });

    // Add new focus handler function
    function handleSearchFocus() {
      // Get all nodes in their original order
      const allNodes = Array.from(nodeElements.data());
      showSearchResults(allNodes);
    }

    // Add resize event listener
    $(window).on('resize', function() {
      if (dataReady) {
        generateGraph();
      }
    });
  });

  /**
   * Parse query parameters:
   * - If custom_graph is present, parse it, store in customGraphEdges; ignore other params except for title.
   * - Otherwise, parse eins/keywords in the BFS usage scenario.
   * Also sets the instructions text, and shows/hides BFS elements accordingly.
   */
  function parseQueryParams() {
    const params = new URLSearchParams(window.location.search);
    customTitle = params.get('title') || null;

    const customParam = params.get('custom_graph');
    if (customParam) {
      // We are in custom-graph mode
      const trimmed = customParam.replace(/;+$/, '');
      const segments = trimmed.split(';');
      let edgeList = [];

      segments.forEach(s => {
        const parts = s.split(',');
        if (parts.length !== 3) return; // skip if malformed
        let [filer, grantee, amt] = parts.map(x => x.trim());
        // Remove dashes/spaces from EINS
        filer = filer.replace(/[-\s]/g, '');
        grantee = grantee.replace(/[-\s]/g, '');
        const num = parseInt(amt, 10);
        if (!isNaN(num)) {
          edgeList.push({ filer, grantee, amt: num });
        }
      });
      customGraphEdges = edgeList;

      // BFS controls are hidden
      $('.bfs-only').hide();
      // Taxpayer controls are hidden
      $('#excluded-info').hide();

const addendum = `
      <br/><br/>
      <p style="font-weight: bold; color: red; background: yellow; text-align: center; padding: 20px; border: 5px solid black;">
          ðŸš¨ðŸš¨ðŸš¨ <strong>WARNING! <a href="https://www.dictionary.com/browse/disclaimer" title="Link to definition if you don't know the word." style="color: inherit; text-decoration: underline;">DISCLAIMER</a>! PAY ATTENTION! HAVE SOME READING <a href="https://www.dictionary.com/browse/comprehension" title="Look it up if you must." style="color: inherit; text-decoration: underline;">COMPREHENSION</a>! ðŸ“¢ðŸ“¢ðŸ“¢</strong> ðŸš¨ðŸš¨ðŸš¨
      </p>

      <p style="color: white; background: black; padding: 15px; text-align: center; border: 3px dashed red;">
          <strong>FUNDING IS <a href="https://www.dictionary.com/browse/fungible" title="Link to definition if you don't know the word." style="color: inherit; text-decoration: underline;">FUNGIBLE</a>!!!</strong> That means <span style="color: yellow; text-transform: uppercase;">USAID DOLLARS DO NOT <a href="https://www.dictionary.com/browse/literally" title="Link to definition if you don't know the word." style="color: inherit; text-decoration: underline;">LITERALLY</a> FLOW INTO THESE NGOS!!!</span> 
      </p>

      <p style="color: black; background: lime; padding: 10px; border: 5px dotted blue; text-align: center;">
          ðŸ’°ðŸ’° Instead, the money <strong>MOVES</strong> through MULTIPLE LAYERS! ðŸ’°ðŸ’° <br/>
          Various entities handle it, shuffle it around, and redistribute it! 
      </p>

      <p style="color: purple; background: orange; font-weight: bold; text-align: center; padding: 20px; border: 5px solid pink;">
          So instead of <a href="https://www.dictionary.com/browse/obsess" title="Link to definition if you don't know the word." style="color: inherit; text-decoration: underline;">obsessing</a> over individual grants and NGOs, OPEN YOUR EYES ðŸ‘€ to the 
          <span style="text-decoration: underline;">BROADER PATTERN of FUNDING <a href="https://www.dictionary.com/browse/distribution" title="Link to definition if you don't know the word." style="color: inherit; text-decoration: underline;">DISTRIBUTION</a> and <a href="https://www.dictionary.com/browse/influence" title="Link to definition if you don't know the word." style="color: inherit; text-decoration: underline;">INFLUENCE</a>!</span> <br/>
          ðŸš¨ðŸš¨ And YESâ€”layers of <strong style="color: red;"><a href="https://www.dictionary.com/browse/accountability" title="Link to definition if you don't know the word." style="color: inherit; text-decoration: underline;">UNACCOUNTABILITY</a></strong> exist! ðŸš¨ðŸš¨
      </p>

      <p style="color: black; background: cyan; text-align: center; padding: 15px; border: 5px double red;">
          ðŸ¤”ðŸ¤” <strong>WHO'S TRULY <a href="https://www.dictionary.com/browse/dependent" title="Link to definition if you don't know the word." style="color: inherit; text-decoration: underline;">DEPENDENT</a> ON USAID?!</strong> ðŸ¤”ðŸ¤” <br/>
          <span style="color: red;">The ones who DON'T want it to be shut down! ðŸ”¥ðŸ”¥ðŸ”¥</span> <br/>
          <strong style="color: blue; text-transform: uppercase;">THIS IS COMMON SENSE!!!</strong> ðŸš¨ðŸš¨ðŸš¨
      </p>


      <p style="font-weight: bold; text-align: center; color: white; background: red; padding: 25px; border: 10px solid black; text-transform: uppercase;">
          THIS IS A TOOL NOT A VERDICT! YOU HAVE BEEN WARNED! ðŸ”¥ðŸ”¥ðŸ”¥
      </p>
`;
      // Show instructions
      if (customTitle) {
        $('#instructions').html('Displaying <strong>' + customTitle + `</strong>${addendum}`);
      } else {
        $('#instructions').text(`Displaying exact graph.${addendum}`);
      }
    } else {
      // BFS scenario: parse EINS, keywords normally
      const einParam = params.get('eins');
      if (einParam) {
        let list = einParam.split(',');
        list.forEach(e => {
          let v = e.replace(/[-\s]/g, '');
          if (/^\d{9}$/.test(v)) {
            if (!activeEINs.includes(v)) {
              activeEINs.push(v);
            }
          }
        });
      }
      const kwParam = params.get('keywords');
      if (kwParam) {
        let kws = kwParam.split(',');
        kws.forEach(k => {
          k = k.trim().toLowerCase();
          if (k && !activeKeywords.includes(k)) {
            activeKeywords.push(k);
          }
        });
      }

      // BFS controls visible
      $('.bfs-only').show();

      // Instructions text for BFS scenario
      $('#instructions').text(
        'Use the search and keywords to filter charities, then BFS expansion is performed automatically.'
      );

      // Render them
      renderActiveEINs();
      renderActiveKeywords();
    }
  }

  /**
   * Update the query parameters to reflect the current activeEINs and activeKeywords.
   * This only applies if we are not in custom-graph mode.
   */
  function updateQueryParams() {
    if (customGraphEdges) {
      // Do nothing if custom_graph is present
      return;
    }
    const params = new URLSearchParams();
    if (activeEINs.length > 0) {
      params.set('eins', activeEINs.join(','));
    }
    if (activeKeywords.length > 0) {
      params.set('keywords', activeKeywords.join(','));
    }
    const newUrl = window.location.pathname + '?' + params.toString();
    window.history.replaceState({}, '', newUrl);
  }

  /**
   * Load charities + grants from the CSV zips.
   */
  async function loadData() {
    $('#status').html('<span class="flex items-center text-sm"><img src="/assets/images/loading.svg" class="size-6" alt="Loading..."> Loading data...</span>');

    // 1) charities
    const charitiesZipBuf = await fetch('charities.csv.zip').then(r => r.arrayBuffer());
    const charitiesZip = await JSZip.loadAsync(charitiesZipBuf);
    const charitiesCsvString = await charitiesZip.file('charities_truncated.csv').async('string');

    await new Promise((resolve, reject) => {
      Papa.parse(charitiesCsvString, {
        header: true,
        skipEmptyLines: true,
        complete: results => {
          results.data.forEach(row => {
            const ein = (row['filer_ein'] || '').trim();
            if (!ein) return;
            let rAmt = parseInt((row['receipt_amt'] || '0').trim(), 10);
            if (isNaN(rAmt)) rAmt = 0;
            charities[ein] = {
              name: (row['filer_name'] || '').trim(),
              xml_name: row['xml_name'],
              receipt_amt: rAmt,
              govt_amt: parseInt((row['govt_amt'] || '0').trim(), 10) || 0,
              contrib_amt: parseInt((row['contrib_amt'] || '0').trim(), 10) || 0,
              grant_amt: 0 // will accumulate below
            };
          });
          totalCharitiesCount = Object.keys(charities).length;
          resolve();
        },
        error: err => reject(err)
      });
    });

    // 2) grants
    const grantsZipBuf = await fetch('grants.csv.zip').then(r => r.arrayBuffer());
    const grantsZip = await JSZip.loadAsync(grantsZipBuf);
    const grantsCsvString = await grantsZip.file('grants_truncated.csv').async('string');

    await new Promise((resolve, reject) => {
      Papa.parse(grantsCsvString, {
        header: true,
        skipEmptyLines: true,
        complete: results => {
          let localEdges = {};
          let count = 0;
          results.data.forEach(row => {
            const filer = (row['filer_ein'] || '').trim();
            const grantee = (row['grant_ein'] || '').trim();
            let amt = parseInt((row['grant_amt'] || '0').trim(), 10);
            if (isNaN(amt)) amt = 0;
            count++;
            if (charities[filer] && charities[grantee]) {
              const key = filer + '~' + grantee;
              if (!localEdges[key]) localEdges[key] = 0;
              localEdges[key] += amt;
              charities[filer].grant_amt += amt;
            }
          });
          edgeAccumulator = localEdges;
          totalGrantsCount = count;
          resolve();
        },
        error: err => reject(err)
      });
    });
  }

  /**
   * The main graph-generation entry point.
   * - If custom_graph is present, we parse and render that directly.
   * - Else, we do BFS logic based on activeEINs & keywords.
   */
  function generateGraph() {
    console.log('1. Starting graph generation');
    if (!dataReady) {
      alert("Data not loaded yet. Please wait.");
      return;
    }

    // Show loading icon
    $('#loading').show();
    console.log('2. Loading icon shown');

    // Clear old graph
    $('#graph-container svg').empty();
    console.log('3. Old graph cleared');

    // Get container dimensions
    const container = document.getElementById('graph-container');
    const width = container.offsetWidth;
    const height = container.offsetHeight || window.innerHeight * 0.7;
    console.log('4. Container dimensions calculated');

    // Create SVG
    const svg = d3.select('#graph')
      .attr('width', '100%')
      .attr('height', '100%')
      .style('display', 'block');
    console.log('5. SVG created');

    // Add zoom behavior
    zoom = d3.zoom()
      .scaleExtent([0.1, 4])
      .on('zoom', (event) => {
        g.attr('transform', event.transform);
      });
    
    svg.call(zoom);
    
    // Main group for zoom/pan
    const g = svg.append('g');

    // Get nodes and edges based on mode
    let { nodes, edges } = customGraphEdges 
      ? getCustomGraphData() 
      : getBFSGraphData();
    console.log('6. Node and edge data prepared', { nodeCount: nodes.length, edgeCount: edges.length });

    // Calculate force parameters first
    const forceParams = getForceParameters(nodes, width, height);
    console.log('7. Force parameters calculated');

    // Create all visual elements first
    console.log('8. Starting to create visual elements');
    
    // Set initial positions before creating elements
    nodes.forEach((node, i) => {
      if (i === 0) {
        node.x = width/2;
        node.y = 100;
      } else {
        const cols = Math.ceil(Math.sqrt(nodes.length - 1));
        const col = (i - 1) % cols;
        const row = Math.floor((i - 1) / cols);
        node.x = (width * 0.2) + (col * width * 0.6 / (cols - 1));
        node.y = 300 + (row * 200);
      }
    });

    // Create link group
    const linkGroup = g.append('g').attr('class', 'links');
    const linkElements = linkGroup.selectAll('g')
      .data(edges)
      .join('g')
      .attr('class', 'link-group');

    // Add this after the linkGroup creation and before creating links
    // Create arrow marker definitions
    const defs = svg.append('defs');
    defs.append('marker')
      .attr('id', 'arrow')
      .attr('viewBox', '0 -5 10 10')
      .attr('refX', 5)
      .attr('refY', 0)
      .attr('markerWidth', 8)
      .attr('markerHeight', 8)
      .attr('orient', 'auto')
      .append('path')
      .attr('d', 'M0,-5L10,0L0,5')
      .attr('fill', '#CBD5E1');

    // Create hover version
    defs.append('marker')
      .attr('id', 'arrow-hover')
      .attr('viewBox', '0 -5 10 10')
      .attr('refX', 5)
      .attr('refY', 0)
      .attr('markerWidth', 8)
      .attr('markerHeight', 8)
      .attr('orient', 'auto')
      .append('path')
      .attr('d', 'M0,-5L10,0L0,5')
      .attr('fill', '#2563EB');

    // Target arrow (normal) - adjusted position
    defs.append('marker')
      .attr('id', 'arrow-target')
      .attr('viewBox', '0 -5 10 10')
      .attr('refX', 25) // Increased from 5 to move inward away from target
      .attr('refY', 0)
      .attr('markerWidth', 8)
      .attr('markerHeight', 8)
      .attr('orient', 'auto')
      .append('path')
      .attr('d', 'M0,-5L10,0L0,5')
      .attr('fill', '#CBD5E1');

    // Target arrow (hover) - adjusted position
    defs.append('marker')
      .attr('id', 'arrow-target-hover')
      .attr('viewBox', '0 -5 10 10')
      .attr('refX', 25) // Increased from 5 to move inward away from target
      .attr('refY', 0)
      .attr('markerWidth', 8)
      .attr('markerHeight', 8)
      .attr('orient', 'auto')
      .append('path')
      .attr('d', 'M0,-5L10,0L0,5')
      .attr('fill', '#2563EB');

    // Source arrow (normal) - adjusted position
    defs.append('marker')
      .attr('id', 'arrow-source')
      .attr('viewBox', '0 -5 10 10')
      .attr('refX', 15) // Increased from 0 to move inward away from source
      .attr('refY', 0)
      .attr('markerWidth', 8)
      .attr('markerHeight', 8)
      .attr('orient', 'auto')
      .append('path')
      .attr('d', 'M0,-5L10,0L0,5')
      .attr('fill', '#CBD5E1');

    // Source arrow (hover) - adjusted position
    defs.append('marker')
      .attr('id', 'arrow-source-hover')
      .attr('viewBox', '0 -5 10 10')
      .attr('refX', 15) // Increased from 0 to move inward away from source
      .attr('refY', 0)
      .attr('markerWidth', 8)
      .attr('markerHeight', 8)
      .attr('orient', 'auto')
      .append('path')
      .attr('d', 'M0,-5L10,0L0,5')
      .attr('fill', '#2563EB');

    // Update the link creation
    const links = linkElements.append('path')
      .attr('class', 'link')
      .attr('stroke', '#CBD5E1')  // Changed from #94A3B8 to lighter gray
      .attr('stroke-width', 3)
      .attr('fill', 'none')
      .attr('marker-start', 'url(#arrow-source)')   // Add marker at start
      .attr('marker-end', 'url(#arrow-target)');    // Add marker at end

    // Update the arrow paths
    const arrowPaths = linkElements.append('path')
      .attr('class', 'arrow-path')
      .attr('stroke', '#CBD5E1')  // Changed from #94A3B8 to lighter gray
      .attr('stroke-width', 3)
      .attr('fill', 'none')
      .attr('marker-end', 'url(#arrow)');

    // Update the hover effect stroke widths
    linkElements.append('path')
      .attr('class', 'link-hover')
      .attr('stroke', 'transparent')
      .attr('stroke-width', 20)
      .attr('fill', 'none')
      .style('cursor', 'pointer')
      .on('click', function(event, d) {
        event.stopPropagation();
        zoomToFitNodes(d.source, d.target);
      })
      .on('mouseover', function(event, d) {
        // Highlight the line and both markers
        d3.select(this.parentNode).select('.link')
          .attr('stroke', '#2563EB')
          .attr('stroke-width', 3)
          .attr('marker-start', 'url(#arrow-source-hover)')
          .attr('marker-end', 'url(#arrow-target-hover)');
        
        // Highlight the label
        labelGroup.selectAll('.link-label-group')
          .filter(l => l === d)
          .each(function() {
            d3.select(this).select('.label-bg')
              .attr('fill', '#2563EB')
              .attr('stroke', '#2563EB');
            d3.select(this).select('.link-label')
              .attr('fill', 'white');
            // Bring label to front
            this.parentNode.appendChild(this);
          });
        
        // Highlight connected nodes
        nodeElements
          .filter(n => n.id === d.source.id || n.id === d.target.id)
          .select('rect')
          .attr('stroke', '#2563EB')
          .attr('stroke-width', 3);
      })
      .on('mouseout', function() {
        // Reset line highlights and markers
        linkElements.selectAll('.link')
          .attr('stroke', '#CBD5E1')
          .attr('stroke-width', 3)
          .attr('marker-start', 'url(#arrow-source)')
          .attr('marker-end', 'url(#arrow-target)');
        
        // Reset label highlights
        labelGroup.selectAll('.label-bg')
          .attr('fill', '#F3F4F6')
          .attr('stroke', 'white');
        labelGroup.selectAll('.link-label')
          .attr('fill', '#475569');
        
        // Reset node highlights
        nodeElements.select('rect')
          .attr('stroke', n => getNodeStroke(n))
          .attr('stroke-width', n => isUserEin(n.id) ? 3 : 1);
      });

    // Update the hover effects
    linkElements.append('path')
      .attr('class', 'link-hover')
      .attr('stroke', 'transparent')
      .attr('stroke-width', 20)
      .attr('fill', 'none')
      .style('cursor', 'pointer')
      .on('click', function(event, d) {  // Add click handler here
        event.stopPropagation(); // Prevent event bubbling
        zoomToFitNodes(d.source, d.target);
      })
      .on('mouseover', function(event, d) {
        d3.select(this.parentNode).select('.link')
          .attr('stroke', '#2563EB')
          .attr('stroke-width', 3);
        d3.select(this.parentNode).select('.arrow-path')
          .attr('stroke', '#2563EB')
          .attr('stroke-width', 3)
          .attr('marker-end', 'url(#arrow-hover)');
        
        // Highlight the label
        labelGroup.selectAll('.link-label-group')
          .filter(l => l === d)
          .each(function() {
            d3.select(this).select('.label-bg')
              .attr('fill', '#2563EB')
              .attr('stroke', '#2563EB');
            d3.select(this).select('.link-label')
              .attr('fill', 'white');
            // Bring label to front
            this.parentNode.appendChild(this);
          });
        
        // Highlight connected nodes
        nodeElements
          .filter(n => n.id === d.source.id || n.id === d.target.id)
          .select('rect')
          .attr('stroke', '#2563EB')
          .attr('stroke-width', 3);
      })
      .on('mouseout', function() {
        linkElements.selectAll('.link')
          .attr('stroke', '#CBD5E1')  // Changed from #94A3B8 to lighter gray
          .attr('stroke-width', 2);
        linkElements.selectAll('.arrow-path')
          .attr('stroke', '#CBD5E1')  // Changed from #94A3B8 to lighter gray
          .attr('stroke-width', 2)
          .attr('marker-end', 'url(#arrow)');
        
        labelGroup.selectAll('.label-bg')
          .attr('fill', '#F3F4F6')
          .attr('stroke', 'white');
        labelGroup.selectAll('.link-label')
          .attr('fill', '#94A3B8');
        nodeElements.select('rect')
          .attr('stroke', n => getNodeStroke(n))
          .attr('stroke-width', n => isUserEin(n.id) ? 3 : 1);
      });

    // Create label group
    const labelGroup = g.append('g').attr('class', 'label-group');
    const linkLabels = labelGroup.selectAll('g')
      .data(edges)
      .join('g')
      .attr('class', 'link-label-group');
    
    // Add background pill
    linkLabels.append('rect')
      .attr('rx', 12) // Fully rounded corners
      .attr('ry', 12)
      .attr('fill', '#F3F4F6') // Light gray background
      .attr('stroke', 'white') // White border
      .attr('stroke-width', 2) // Thick enough to create padding
      .attr('class', 'label-bg')
      .style('cursor', 'pointer')
      .on('click', function(event, d) {  // Add click handler here
        event.stopPropagation(); // Prevent event bubbling
        zoomToFitNodes(d.source, d.target);
      })
      // Add hover effects to label background
      .on('mouseover', function(event, d) {
        const labelGroup = d3.select(this.parentNode);
        // Highlight this label
        labelGroup.select('.label-bg')
          .attr('fill', '#2563EB')
          .attr('stroke', '#2563EB');
        labelGroup.select('.link-label')
          .attr('fill', 'white');
        // Bring label to front
        this.parentNode.parentNode.appendChild(this.parentNode);
        
        // Highlight corresponding link
        linkElements
          .filter(l => l === d)
          .select('.link')
          .attr('stroke', '#2563EB')
          .attr('stroke-width', 3);
          
        // Highlight connected nodes
        nodeElements
          .filter(n => n.id === d.source.id || n.id === d.target.id)
          .select('rect')
          .attr('stroke', '#2563EB')
          .attr('stroke-width', 3);
      })
      .on('mouseout', function() {
        // Reset all highlights
        labelGroup.selectAll('.label-bg')
          .attr('fill', '#F3F4F6')
          .attr('stroke', 'white');
        labelGroup.selectAll('.link-label')
          .attr('fill', '#475569');  // Darker gray for text
        linkElements.selectAll('.link')
          .attr('stroke', '#CBD5E1')
          .attr('stroke-width', 3);
        nodeElements.select('rect')
          .attr('stroke', n => getNodeStroke(n))
          .attr('stroke-width', n => isUserEin(n.id) ? 3 : 1);
      });
    
    // Add text
    linkLabels.append('text')
      .attr('class', 'link-label')
      .attr('dy', '0.35em')
      .attr('text-anchor', 'middle')
      .attr('fill', '#475569')
      .attr('font-size', '14px')
      .text(d => `$${formatNumber(d.amt)}`) // Remove arrows, only show dollar amount
      .style('cursor', 'pointer')
      .style('pointer-events', 'all')
      .on('click', function(event, d) {
        event.stopPropagation();
        zoomToFitNodes(d.source, d.target);
      })
      .on('mouseover', function(event, d) {
        // Highlight this label
        const labelGroup = d3.select(this.parentNode);
        labelGroup.select('.label-bg')
          .attr('fill', '#2563EB')
          .attr('stroke', '#2563EB');
        d3.select(this)
          .attr('fill', 'white');
        
        // Highlight corresponding link
        linkElements
          .filter(l => l === d)
          .select('.link')
          .attr('stroke', '#2563EB')
          .attr('stroke-width', 3);
      })
      .on('mouseout', function() {
        // Reset all highlights
        labelGroup.selectAll('.label-bg')
          .attr('fill', '#F3F4F6')
          .attr('stroke', 'white');
        labelGroup.selectAll('.link-label')
          .attr('fill', '#475569');
        linkElements.selectAll('.link')
          .attr('stroke', '#CBD5E1')
          .attr('stroke-width', 3);
      });

    // Create nodes
    const nodeGroup = g.append('g').attr('class', 'nodes');
    nodeElements = nodeGroup.selectAll('g')
      .data(nodes)
      .join('g')
      .attr('class', 'node')
      .attr('data-id', d => d.id)
      // Only add drag behavior on non-touch devices
      .call(d3.drag()
        .filter(event => {
          // Completely ignore touch events, only allow mouse events
          if (event.sourceEvent.type.startsWith('touch')) {
            return false;
          }
          // Only allow left mouse button
          return event.button === 0;
        })
        .on('start', event => {
          if (!event.active) simulation.alphaTarget(0.3).restart();
          event.subject.fx = event.subject.x;
          event.subject.fy = event.subject.y;
        })
        .on('drag', event => {
          event.subject.fx = event.x;
          event.subject.fy = event.y;
        })
        .on('end', event => {
          if (!event.active) simulation.alphaTarget(0);
          event.subject.fx = null;
          event.subject.fy = null;
        })
      );

    // Node rectangles
    nodeElements.append('rect')
      .attr('rx', 4)
      .attr('ry', 4)
      .attr('width', d => getNodeWidth(d))
      .attr('height', d => getNodeHeight(d))
      .attr('fill', d => getNodeColor(d))
      .attr('stroke', d => getNodeStroke(d))
      .attr('stroke-width', d => isUserEin(d.id) ? 3 : 1)
      .style('cursor', 'grab')
      .style('transition', 'filter 0.2s ease');

    // Node content (name, EIN, amounts)
    nodeElements.each(function(d) {
      const node = d3.select(this);
      const charity = charities[d.id];
      const padding = 15;
      const horizontalPadding = 16; // Increased horizontal padding
      const rightPadding = horizontalPadding; // Match left padding
      let y = 0; // Start at top for alert, or add padding if no alert

      // High taxpayer alert if needed
      if (charity.govt_amt > 10000000) {
        const alertGroup = node.append('g')
          .attr('transform', `translate(0, 0)`);
        
        alertGroup.append('rect')
          .attr('width', getNodeWidth(d))
          .attr('height', 30)
          .attr('rx', 4) // Match parent box rounded corners
          .attr('ry', 4)
          .attr('fill', '#EF3E28');
        
        alertGroup.append('text')
          .attr('x', getNodeWidth(d) / 2)
          .attr('y', 20)
          .attr('text-anchor', 'middle')
          .attr('fill', 'white')
          .attr('font-weight', 'bold')
          .text('ðŸš¨ High Taxpayer Funds Alert! ðŸš¨');
        
        y += 45; // Add 15px margin below alert bar
      } else {
        y += padding; // Only add top padding if no alert
      }

      // Name
      const nameText = node.append('text')
        .attr('x', horizontalPadding)
        .attr('y', y + padding)
        .attr('fill', '#000')
        .attr('font-weight', 'bold')
        .attr('font-size', '14px');

      // Word wrap the name
      const words = charity.name.split(/\s+/);
      let line = [];
      let lineNumber = 0;
      const lineHeight = 1.1; // Reduced line height
      const maxWidth = getNodeWidth(d) - (horizontalPadding * 2);

      words.forEach(word => {
        line.push(word);
        const testLine = line.join(' ');
        const testWidth = getTextWidth(testLine, '14px bold sans-serif');
        
        if (testWidth > maxWidth) {
          if (lineNumber < 2) { // Max 2 lines
            nameText.append('tspan')
              .attr('x', horizontalPadding)
              .attr('dy', lineNumber ? lineHeight + 'em' : 0)
              .text(line.slice(0, -1).join(' '));
            line = [word];
            lineNumber++;
          } else {
            // Add ellipsis if too long
            const lastLine = line.slice(0, -1).join(' ') + '...';
            nameText.append('tspan')
              .attr('x', horizontalPadding)
              .attr('dy', lineHeight + 'em')
              .text(lastLine);
            line = [];
          }
        }
      });
      
      if (line.length > 0 && lineNumber < 3) {
        nameText.append('tspan')
          .attr('x', horizontalPadding)
          .attr('dy', lineNumber ? lineHeight + 'em' : 0)
          .text(line.join(' '));
      }

      y += (lineNumber + 1) * 20 + 5; // Reduced spacing after name

      // EIN
      node.append('text')
        .attr('x', horizontalPadding)
        .attr('y', y += 15) // Reduced spacing for EIN
        .attr('fill', '#252739')
        .attr('opacity', '0.8')
        .attr('font-size', '13px')
        .text(`EIN: ${d.id.slice(0,2)}-${d.id.slice(2)}`);

      // Dividing line
      node.append('line')
        .attr('x1', horizontalPadding)
        .attr('x2', getNodeWidth(d) - horizontalPadding)
        .attr('y1', y + 10)
        .attr('y2', y + 10)
        .attr('stroke', '#252739')
        .attr('stroke-opacity', 0.2);

      y += 15; // Reduced space after divider

      // Amounts
      const amounts = [
        ['Gross receipts', charity.receipt_amt],
        ['Contributions', charity.contrib_amt],
        ['Grants given', charity.grant_amt],
        ['Taxpayer funds', charity.govt_amt]
      ];

      amounts.forEach(([label, amount]) => {
        const isTaxpayer = label === 'Taxpayer funds' && amount > 0;
        
        // Label (left-aligned)
        node.append('text')
          .attr('x', horizontalPadding)
          .attr('y', y += 20)
          .attr('fill', isTaxpayer ? '#EF3E28' : '#000')
          .attr('font-weight', label === 'Taxpayer funds' ? 'bold' : 'normal')
          .attr('font-size', '13px')
          .text(label);

        // Amount (right-aligned)
        node.append('text')
          .attr('x', getNodeWidth(d) - horizontalPadding)
          .attr('y', y)
          .attr('text-anchor', 'end')
          .attr('fill', isTaxpayer ? '#EF3E28' : '#000')
          .attr('font-weight', label === 'Taxpayer funds' ? 'bold' : 'normal')
          .attr('font-size', '13px')
          .text(`$${formatNumber(amount)}`);
      });
    });

    // Node hover effects
    nodeElements
      .on('mouseover', function(event, d) {
        // Highlight this node
        d3.select(this)
          .style('filter', 'drop-shadow(0 4px 6px rgba(0, 0, 0, 0.1))')
          .select('rect')
          .attr('stroke', '#2563EB')
          .attr('stroke-width', 3);

        // Highlight connected links and nodes
        linkElements.each(function(l) {
          if (l.source.id === d.id || l.target.id === d.id) {
            d3.select(this).select('.link')
              .attr('stroke', '#2563EB')
              .attr('stroke-width', 3);

            // Highlight the label
            labelGroup.selectAll('.link-label-group')
              .filter(lg => lg === l)
              .each(function() {
                d3.select(this).select('.label-bg')
                  .attr('fill', '#2563EB')
                  .attr('stroke', '#2563EB');
                d3.select(this).select('.link-label')
                  .attr('fill', 'white');
                // Bring label to front
                this.parentNode.appendChild(this);
              });

            // Also highlight connected node
            nodeElements
              .filter(n => n.id === (l.source.id === d.id ? l.target.id : l.source.id))
              .select('rect')
              .attr('stroke', '#2563EB')
              .attr('stroke-width', 3);
          }
        });
      })
      .on('mousedown', function() {
        d3.select(this).style('cursor', 'grabbing');
      })
      .on('mouseup', function() {
        d3.select(this).style('cursor', 'grab');
      })
      .on('mouseout', function() {
        // Reset all node highlights
        d3.select(this).style('filter', 'none');
        nodeElements.select('rect')
          .attr('stroke', n => getNodeStroke(n))
          .attr('stroke-width', n => isUserEin(n.id) ? 3 : 1);
        // Reset all link highlights
        linkElements.selectAll('.link')
          .attr('stroke', '#CBD5E1')  // Changed from #94A3B8 to lighter gray
          .attr('stroke-width', 2);
        // Reset label highlights
        labelGroup.selectAll('.label-bg')
          .attr('fill', '#F3F4F6')
          .attr('stroke', 'white');
        labelGroup.selectAll('.link-label')
          .attr('fill', '#94A3B8');
      });

    // Handle zoom controls
    document.getElementById('zoomIn').onclick = () => {
      svg.transition().duration(300).call(zoom.scaleBy, 1.3);
    };

    document.getElementById('zoomOut').onclick = () => {
      svg.transition().duration(300).call(zoom.scaleBy, 0.7);
    };

    document.getElementById('zoomFit').onclick = () => {
      const bounds = g.node().getBBox();
      const dx = bounds.x;
      const dy = bounds.y;
      const scale = 0.8 / Math.max(
        bounds.width / width,
        bounds.height / height
      );

      svg.transition()
        .duration(750)
        .call(zoom.transform,
          d3.zoomIdentity
            .translate(width/2, height/2)
            .scale(scale)
            .translate(-dx-bounds.width/2, -dy-bounds.height/2));
    };

    // Also update the initial zoom to account for the larger bounds
    setTimeout(() => {
      const bounds = g.node().getBBox();
      const dx = bounds.x;
      const dy = bounds.y;
      const scale = 0.8 / Math.max( // Increased scale for better initial fit
        bounds.width / width,
        bounds.height / height
      );

      svg.transition()
        .duration(750)
        .call(zoom.transform,
          d3.zoomIdentity
            .translate(width/2, height/2)
            .scale(scale)
            .translate(-dx-bounds.width/2, -dy-bounds.height/2));
    }, 1000);

    // Update status
    $('#status').html(`<span class="text-sm text-green font-semibold">${nodes.length} charities displayed</span>`);
    $('#downloadBtn').show();

    // Now start the simulation
    simulation = d3.forceSimulation(nodes)
      .force('link', d3.forceLink(edges)
        .id(d => d.id)
        .distance(forceParams.linkDistance))
      .force('charge', d3.forceManyBody()
        .strength(forceParams.charge)
        .distanceMin(200)
        .distanceMax(forceParams.linkDistance * 2))
      .force('x', d3.forceX(d => {
        const isSource = edges.every(e => e.target.id !== d.id);
        const isSink = edges.every(e => e.source.id !== d.id);
        
        if (isSource) {
          return width * 0.1;
        } else if (isSink) {
          return width * 0.9;
        } else {
          return width * 0.5;
        }
      }).strength(1))
      .force('y', d3.forceY(height / 2).strength(0.1))
      .force('collision', d3.forceCollide().radius(forceParams.collisionRadius))
      .alpha(0.3)
      .alphaDecay(0.05)
      .velocityDecay(0.5)
      .on('tick', () => {
        // Validate and fix node positions
        nodes.forEach(node => {
          if (isNaN(node.x) || isNaN(node.y)) {
            // Reset to center if position becomes invalid
            node.x = width/2;
            node.y = height/2;
          }
          
          // Get node dimensions
          const nodeWidth = getNodeWidth(node);
          const nodeHeight = getNodeHeight(node);
          
          // Constrain to bounds with validation
          node.x = Math.max(forceParams.bounds.left + nodeWidth/2, 
            Math.min(forceParams.bounds.right - nodeWidth/2, node.x || width/2));
          node.y = Math.max(forceParams.bounds.top + nodeHeight/2, 
            Math.min(forceParams.bounds.bottom - nodeHeight/2, node.y || height/2));
        });

        // Update node positions with validation
        nodeElements.attr('transform', d => {
          const nodeWidth = getNodeWidth(d);
          const nodeHeight = getNodeHeight(d);
          const x = (isNaN(d.x) ? width/2 : d.x) - nodeWidth/2;
          const y = (isNaN(d.y) ? height/2 : d.y) - nodeHeight/2;
          return `translate(${x},${y})`;
        });

        // Update link paths with validation
        links.attr('d', d => {
          if (!d.source || !d.target) return '';

          // Handle self-loops (when source and target are the same node)
          if (d.source.id === d.target.id) {
            const nodeWidth = getNodeWidth(d.source);
            const nodeHeight = getNodeHeight(d.source);
            const offset = 60;
            
            // Create a more rectangular loop with straight segments
            return `
              M ${d.source.x + nodeWidth/2},${d.source.y - nodeHeight/4} 
              L ${d.source.x + nodeWidth/2 + offset},${d.source.y - nodeHeight/4}
              L ${d.source.x + nodeWidth/2 + offset},${d.source.y + nodeHeight/4}
              L ${d.source.x + nodeWidth/2},${d.source.y + nodeHeight/4}
            `;
          }

          // Get all connections for this source/target (same code as before)
          const topConnections = getConnectionsToSide(edges, d.source.id, 'top')
            .sort((a, b) => a.target.x - b.target.x);
          const bottomConnections = getConnectionsToSide(edges, d.source.id, 'bottom')
            .sort((a, b) => a.target.x - b.target.x);
          const leftConnections = getConnectionsToSide(edges, d.source.id, 'left')
            .sort((a, b) => a.target.y - b.target.y);
          const rightConnections = getConnectionsToSide(edges, d.source.id, 'right')
            .sort((a, b) => a.target.y - b.target.y);

          // Determine the best side to connect from based on relative positions
          let sourceSide, targetSide;
          let sourceConnections, targetConnections;
          
          // Calculate angle between nodes to determine optimal connection sides
          const dx = d.target.x - d.source.x;
          const dy = d.target.y - d.source.y;
          const angle = Math.atan2(dy, dx) * 180 / Math.PI;
          
          // Determine source side based on angle (same code as before)
          if (angle > -45 && angle < 45) {
            sourceSide = 'right';
            sourceConnections = rightConnections;
            targetSide = 'left';
          } else if (angle >= 45 && angle < 135) {
            sourceSide = 'bottom';
            sourceConnections = bottomConnections;
            targetSide = 'top';
          } else if (angle >= 135 || angle < -135) {
            sourceSide = 'left';
            sourceConnections = leftConnections;
            targetSide = 'right';
          } else {
            sourceSide = 'top';
            sourceConnections = topConnections;
            targetSide = 'bottom';
          }

          const connectionIndex = sourceConnections.indexOf(d);

          // Get distributed connection points
          const sourcePoint = getSpacedConnectionPoint(
            d.source,
            sourceConnections,
            connectionIndex,
            sourceSide,
            getNodeWidth(d.source)
          );

          // Get the target connection point at the appropriate edge
          targetConnections = getConnectionsToSide(edges, d.target.id, targetSide);
          const targetConnectionIndex = targetConnections.indexOf(d);
          
          const targetPoint = getSpacedConnectionPoint(
            d.target,
            targetConnections,
            Math.max(0, targetConnectionIndex),
            targetSide,
            getNodeWidth(d.target)
          );

          // Generate orthogonal path instead of curved path
          return generateOrthogonalPath(
            sourcePoint, 
            targetPoint,
            sourceSide,
            targetSide,
            connectionIndex,
            sourceConnections.length
          );
        });

        // Update the arrow paths similarly
        arrowPaths.attr('d', function(d) {
          if (d.source.id === d.target.id) {
            // For self-loops, create a shorter arrow path near the end of the loop
            const nodeWidth = getNodeWidth(d.source);
            const nodeHeight = getNodeHeight(d.source);
            const offset = 50; // Slightly less than the loop offset
            
            // Create a small directed segment for the arrow near the return point
            return `
              M ${d.source.x + nodeWidth/2 + offset},${d.source.y + nodeHeight/8}
              L ${d.source.x + nodeWidth/2 + offset - 5},${d.source.y + nodeHeight/5}
            `;
          }
          
          // Use the same logic as above to get the path for this connection...
          // Instead of duplicating all the code, get the path from the link
          const pathNode = d3.select(this.parentNode).select('.link').node();
          if (!pathNode) return '';
          
          const totalLength = pathNode.getTotalLength();
          const midPoint = pathNode.getPointAtLength(totalLength / 2);
          const beforeMid = pathNode.getPointAtLength((totalLength / 2) - 1);
          
          return `M ${beforeMid.x},${beforeMid.y} L ${midPoint.x},${midPoint.y}`;
        });

        // Update hover paths and labels with the same validation
        linkElements.select('.link-hover')
          .attr('d', function() {
            const path = d3.select(this.parentNode).select('.link').attr('d');
            return path || '';  // Return empty string if path is invalid
          });

        // In the tick function, after updating the paths, add:
        // Update link labels with background
        linkLabels.attr('transform', function(d) {
          if (d.source.id === d.target.id) {
            // Handle self-loop labels
            const nodeWidth = getNodeWidth(d.source);
            const nodeHeight = getNodeHeight(d.source);
            
            // Position the label to the right of the node, centered on the loop
            return `translate(${d.source.x + nodeWidth/2 + 80}, ${d.source.y})`;
          }
          
          // Find the corresponding link path using the data, not DOM selection
          const pathNode = linkElements
            .filter(l => l.source === d.source && l.target === d.target)
            .select('.link')
            .node();
            
          if (!pathNode) return '';
          
          // Get the point halfway along the path
          const pathLength = pathNode.getTotalLength();
          const midPoint = pathNode.getPointAtLength(pathLength / 2);
          
          // Remove vertical offset to center on line
          const mx = midPoint.x;
          const my = midPoint.y;
          
          // Get the text width to size the background
          const text = d3.select(this).select('text');
          const textNode = text.node();
          const textWidth = textNode ? textNode.getComputedTextLength() : 0;
          
          // Update background size and position to center vertically
          d3.select(this).select('.label-bg')
            .attr('x', -textWidth/2 - 8)
            .attr('y', -12)
            .attr('width', textWidth + 16)
            .attr('height', 24);
          
          return `translate(${mx},${my})`;
        });
      })
      .on('end', () => {
        console.log('13. Force simulation ended');
        // Fade out loading screen
        const loadingEl = document.getElementById('loading');
        loadingEl.style.opacity = '0';
        setTimeout(() => {
          loadingEl.style.display = 'none';
        }, 200);
        $('#status').html(`<span class="text-sm text-green font-semibold">${nodes.length} charities displayed</span>`);
        $('#downloadBtn').show();
        console.log('14. Loading complete, graph should be visible');

        // Zoom to first node
        if (nodes.length > 0) {
          const firstNode = nodes[0];
          const nodeEl = nodeElements.filter(n => n.id === firstNode.id).node();
          if (nodeEl) {
            const box = nodeEl.getBBox();
            const padding = 50;
            const bounds = {
              x: firstNode.x - box.width/2 - padding,
              y: firstNode.y - box.height/2 - padding,
              width: box.width + (padding * 2),
              height: box.height + (padding * 2)
            };
            
            // Calculate final scale (closer zoom)
            const finalScale = (0.9 / Math.max(
              bounds.width / width,
              bounds.height / height
            )) / 4 * 1.875;  // Increased from 1.5 to 1.875 (25% more)
            
            // Start from a more zoomed out view
            svg.call(zoom.transform,
              d3.zoomIdentity
                .translate(width/2, height/2)
                .scale(finalScale / 2)  // Start at half the final scale
                .translate(
                  -(bounds.x + bounds.width/2),
                  -(bounds.y + bounds.height/2)
                )
            );
            
            // Then transition to final zoom over longer duration
            svg.transition()
              .duration(1500)  // Keep the same duration
              .call(zoom.transform,
                d3.zoomIdentity
                  .translate(width/2, height/2)
                  .scale(finalScale)
                  .translate(
                    -(bounds.x + bounds.width/2),
                    -(bounds.y + bounds.height/2)
                  )
              );
          }
        }
      })
      .restart();

    // After nodes and edges are loaded, but before simulation starts:
    console.log('Node connectivity analysis:');

    // Create a map to count inputs and outputs
    const inputCounts = {};
    const outputCounts = {};

    // Initialize counts
    nodes.forEach(node => {
      inputCounts[node.id] = 0;
      outputCounts[node.id] = 0;
    });

    // Count inputs and outputs
    edges.forEach(edge => {
      outputCounts[edge.source.id] = (outputCounts[edge.source.id] || 0) + 1;
      inputCounts[edge.target.id] = (inputCounts[edge.target.id] || 0) + 1;
    });

    // Log the counts for each node in order
    nodes.forEach(node => {
      const charity = charities[node.id];
      console.log(`Node: ${charity.name}
        EIN: ${node.id}
        Inputs: ${inputCounts[node.id]}
        Outputs: ${outputCounts[node.id]}
        Type: ${inputCounts[node.id] === 0 ? 'SOURCE' : outputCounts[node.id] === 0 ? 'SINK' : 'INTERMEDIATE'}
        ----------------------------------------`);
    });

    // Replace the existing loading name code with this:
    // Add this after step 8:
    const loadingText = document.getElementById('loading-text');
    const loadingCharities = document.getElementById('loading-charities');
    loadingText.textContent = 'Building visualization...';

    // Start adding charity names
    let currentCharityIndex = 0;
    const charityNames = nodes.map(n => charities[n.id].name);

    function addNextCharity() {
      if (!document.getElementById('loading').offsetParent) {
        // Stop if loading div is hidden
        return;
      }

      if (currentCharityIndex < charityNames.length) {
        // Create new element for this charity
        const div = document.createElement('div');
        div.className = 'opacity-0 transition-opacity duration-300 py-1';
        div.textContent = charityNames[currentCharityIndex];
        
        // Add to container
        loadingCharities.appendChild(div);
        
        // Trigger fade in
        setTimeout(() => {
          div.style.opacity = '1';
          // Scroll to bottom
          loadingCharities.scrollTop = loadingCharities.scrollHeight;
        }, 50);

        // Setup next charity
        currentCharityIndex++;
        
        // Queue next addition
        setTimeout(addNextCharity, 750);
      }
    }

    // Start adding charities
    addNextCharity();
  }

  // Helper functions for graph data preparation
  function getCustomGraphData() {
    // First collect all unique EINs that exist in our data
    const uniqueEins = new Set();
    customGraphEdges.forEach(e => {
      if (charities[e.filer]) uniqueEins.add(e.filer);
      if (charities[e.grantee]) uniqueEins.add(e.grantee);
    });

    // Create edges only for EINs that exist in our data
    const edges = customGraphEdges
      .filter(e => charities[e.filer] && charities[e.grantee])
      .map(e => ({
        source: e.filer,
        target: e.grantee,
        amt: e.amt
      }));

    return {
      nodes: Array.from(uniqueEins).map(id => ({ id })),
      edges
    };
  }

  function getBFSGraphData() {
    const { filteredCharities, filteredEdges } = buildFilteredData();
    const visitedSet = multiRootBFS(filteredCharities, buildAdjacency(filteredEdges));
    
    // Force include user EINS
    activeEINs.forEach(ein => {
      if (filteredCharities[ein]) visitedSet.add(ein);
    });

    // Build final edges
    const edges = [];
    Object.entries(filteredEdges).forEach(([key, amt]) => {
      const [filer, grantee] = key.split('~');
      if (visitedSet.has(filer) && visitedSet.has(grantee)) {
        edges.push({ source: filer, target: grantee, amt });
      }
    });

    return {
      nodes: Array.from(visitedSet).map(id => ({ id })),
      edges
    };
  }

  // Force simulation helpers
  function dragstarted(event, d) {
    if (!event.active && simulation) simulation.alphaTarget(0.3).restart();
    d.fx = d.x;
    d.fy = d.y;
  }

  function dragged(event, d) {
    d.fx = event.x;
    d.fy = event.y;
  }

  function dragended(event, d) {
    if (!event.active && simulation) simulation.alphaTarget(0);
    d.fx = null;
    d.fy = null;
  }

  /**
   * Build a filtered subset of charities + edges (for BFS scenario).
   * - If activeKeywords is non-empty, a charity must match at least one or be in activeEINs.
   * - If no keywords, we include all charities plus the user EINS.
   */
  function buildFilteredData() {
    let filteredCharities = {};
    const hasKeywords = (activeKeywords.length > 0);

    for (const [ein, c] of Object.entries(charities)) {
      if (activeEINs.includes(ein)) {
        // Always keep user-specified EIN
        filteredCharities[ein] = c;
        continue;
      }
      if (hasKeywords) {
        // Must match at least one keyword
        const nm = c.name.toLowerCase();
        const matched = activeKeywords.some(kw => nm.includes(kw));
        if (matched) {
          filteredCharities[ein] = c;
        }
      } else {
        // No keywords => keep everything
        filteredCharities[ein] = c;
      }
    }

    // Filter edges so that both ends are in the filtered set
    let filteredEdges = {};
    for (const [key, amt] of Object.entries(edgeAccumulator)) {
      const [filer, grantee] = key.split('~');
      if (filteredCharities[filer] && filteredCharities[grantee]) {
        filteredEdges[key] = amt;
      }
    }

    return { filteredCharities, filteredEdges };
  }

  /**
   * Build DOT string. 
   */
  function buildDotSource(nodeSet, edgeList, filteredCharities, taxpayerTotal) {
    let dot = `digraph G {
rankdir=LR;
nodesep=0.5;
ranksep=0.5;
node [
  shape=box,
  style="filled",
  fillcolor="#F3F4F6",
  color="#94A3B8",
  fontname="SF Pro, Helvetica, sans-serif",
  fontsize=14,
  margin=0.1,
  penwidth=1
];
edge [
  fontname="SF Pro, Helvetica, sans-serif",
  color="#DADBE7",
  penwidth=2,
  fontsize=11,
  decorate=true,
  labelangle=0,
  labeldistance=2
];
graph [
  fontname="SF Pro, Helvetica, sans-serif",
  splines=spline,
  overlap=false
];
labelloc="t";\n`;

    for (const ein of nodeSet) {
      const c = filteredCharities[ein];
      if (!c) continue; // safety

      let escapedName = c.name.replace(/[&<>"']/g, char => {
        switch (char) {
          case '&': return '&amp;';
          case '<': return '&lt;';
          case '>': return '&gt;';
          case '"': return '&quot;';
          case "'": return '&apos;';
          default: return char;
        }
      });

      // If we are in BFS scenario (customGraphEdges == null), highlight keywords
      if (!customGraphEdges && activeKeywords.length > 0) {
        activeKeywords.forEach(kw => {
          const regex = new RegExp(`(\\s*)(${kw})`, 'gi');
          escapedName = escapedName.replace(regex, '$1<B><FONT COLOR="#2563EB">$2</FONT></B> ').trim();
        });
      }

      const receipts = formatNumber(c.receipt_amt);
      const govt = formatNumber(c.govt_amt);
      const contrib = formatNumber(c.contrib_amt);
      const grants = formatNumber(c.grant_amt);

      const label = `<<TABLE BORDER="0" CELLBORDER="0" CELLSPACING="2" cellpadding="2">
        ${
          c.govt_amt > 10000000 
          ? `<tr><td colspan="4"><table border="0" cellspacing="0" cellpadding="5"><tr><td colspan="2" BGCOLOR="#DC2626">
             <font color="white"><b>ðŸš¨ðŸš¨ðŸš¨ High Taxpayer Funds Alert! ðŸš¨ðŸš¨ðŸš¨</b></font>
             </td></tr></table></td></tr>` 
          : ''
        }
        <tr><td colspan="4"><table border="0" cellspacing="0" cellpadding="0"><tr><td colspan="4" height="2"></td></tr></table></td></tr>
        <tr><td colspan="3" align="left"><b>${escapedName}</b></td><td>&nbsp;</td></tr>
        <tr><td colspan="3" align="left">EIN: ${ein.slice(0,2)}-${ein.slice(2)}</td><td>&nbsp;</td></tr>
        <tr><td colspan="4">
          <table border="0" cellspacing="0" cellpadding="0"><tr><td colspan="2" bgcolor="#000000" height="2"></td></tr></table>
        </td></tr>
        <tr><td align="left">Gross receipts</td><td>&nbsp;</td><td align="right">$${receipts}</td><td>&nbsp;</td></tr>
        <tr><td align="left">Contributions</td><td>&nbsp;</td><td align="right">$${contrib}</td><td>&nbsp;</td></tr>
        <tr><td align="left">Grants given (visible)</td><td>&nbsp;</td><td align="right">$${grants}</td><td>&nbsp;</td></tr>
        <tr>
          <td colspan="3">
            <table border="0" cellspacing="0" cellpadding="0">
              <tr>
                <td align="left"><font ${c.govt_amt > 0 ? 'color="#DC2626"' : 'color="#000"'}><b>Taxpayer funds</b></font></td>
                <td align="right"><font ${c.govt_amt > 0 ? 'color="#DC2626"' : 'color="#000"'}><b>$${govt}</b></font></td>
              </tr>
            </table>
          </td>
          <td>&nbsp;</td>
        </tr>
      </TABLE>>`;

      // Color logic: highlight user EINS if BFS scenario
      let nodeStyle = '';
      const isUserEin = (!customGraphEdges && activeEINs.includes(ein));
      if (isUserEin) {
        // BFS scenario, user-searched node
        if (c.govt_amt > 10000000) {
          nodeStyle = 'fillcolor="#FEE2E2" color="#DC2626" penwidth=3';
        } else if (c.govt_amt > 1000000) {
          nodeStyle = 'fillcolor="#FEF3C7" color="#D97706" penwidth=3';
        } else {
          // Blue highlight if user-specified but not a high govt amt
          nodeStyle = 'fillcolor="#F3F4F6" color="#2563EB" penwidth=3';
        }
      } else {
        // Normal styling
        if (c.govt_amt > 10000000) {
          nodeStyle = 'fillcolor="#FEE2E2" color="#DC2626"';
        } else if (c.govt_amt > 1000000) {
          nodeStyle = 'fillcolor="#FEF3C7" color="#D97706"';
        } else if (c.govt_amt > 0) {
          nodeStyle = 'fillcolor="#F3F4F6" color="#4B5563"';
        } else {
          nodeStyle = 'fillcolor="#F3F4F6" color="#94A3B8"';
        }
      }

      dot += `  "${ein}" [${nodeStyle}, label=${label}];\n`;
    }

    // Edges
    for (const e of edgeList) {
      const amt = formatNumber(e.amt);
      dot += `  "${e.filer}" -> "${e.grantee}" [label="$${amt}", color="#94A3B8"];\n`;
    }

    dot += `}\n`;
    return dot;
  }

  function formatNumber(x) {
    const n = parseInt(x, 10) || 0;
    return n.toLocaleString('en-US');
  }

  function addEINFromInput() {
    let val = $('#einInput').val().trim();
    val = val.replace(/[-\s]/g, ''); // Remove hyphens and spaces first
    
    if (!/^\d{9}$/.test(val)) {
      alert("EIN must be 9 digits after removing dashes/spaces.");
      return;
    }
    if (!charities[val]) {
      console.warn("EIN not found in charities.csv (still adding).");
    }
    if (!activeEINs.includes(val)) {
      activeEINs.push(val);
    }
    $('#einInput').val('');
    renderActiveEINs();
    updateQueryParams();
    generateGraph();
  }

  function renderActiveEINs() {
    const $c = $('#activeEINs');
    $c.empty();
    $('#clearEINsBtn').toggle(activeEINs.length > 0);

    activeEINs.forEach(ein => {
      const $tag = $('<div class="filter-tag flex items-center gap-0.5 rounded border border-blue bg-blue/10 text-blue rounded-md px-2 py-1 text-xs"></div>');
      const $text = $('<span></span>').text(ein.slice(0,2) + '-' + ein.slice(2));
      const $rm = $('<span class="remove-filter opacity-50 hover:opacity-100 size-5 -my-0.5 -mr-1 cursor-pointer">{% include close.html %}</span>').attr('data-ein', ein);
      $rm.on('click', function() {
        const rem = $(this).attr('data-ein');
        activeEINs = activeEINs.filter(x => x !== rem);
        renderActiveEINs();
        updateQueryParams();
        generateGraph();
      });
      $tag.append($text).append($rm);
      $c.append($tag);
    });
  }

  function addKeywordFromInput() {
    const kw = $('#keywordInput').val().trim();
    if (kw.length > 0) {
      activeKeywords.push(kw.toLowerCase());
      $('#keywordInput').val('');
      renderActiveKeywords();
      updateQueryParams();
      generateGraph();
    }
  }

  function renderActiveKeywords() {
    const $c = $('#activeFilters');
    $c.empty();
    $('#clearFiltersBtn').toggle(activeKeywords.length > 0);

    activeKeywords.forEach(kw => {
      const $tag = $('<div class="filter-tag flex items-center gap-0.5 rounded border border-blue bg-blue/10 text-blue rounded-md px-2 py-1 text-xs"></div>');
      const $text = $('<span></span>').text(kw);
      const $rm = $('<span class="remove-filter opacity-50 hover:opacity-100 size-5 -my-0.5 -mr-1 cursor-pointer">{% include close.html %}</span>').attr('data-kw', kw);
      $rm.on('click', function() {
        const rem = $(this).attr('data-kw');
        activeKeywords = activeKeywords.filter(x => x !== rem);
        renderActiveKeywords();
        updateQueryParams();
        generateGraph();
      });
      $tag.append($text).append($rm);
      $c.append($tag);
    });
  }

  /**
   * Download the currently displayed SVG as a file named "charity_graph.svg".
   */
  function downloadSVG() {
    const svgEl = document.querySelector('#graph-container svg');
    if (!svgEl) {
      alert('No SVG to download yet.');
      return;
    }
    const svgData = new XMLSerializer().serializeToString(svgEl);
    const blob = new Blob([svgData], { type: 'image/svg+xml;charset=utf-8' });
    const url = URL.createObjectURL(blob);

    const link = document.createElement('a');
    link.href = url;
    link.download = 'charity_graph.svg';
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(url);
  }

  function buildAdjacency(edges) {
    const fwd = {};
    const rev = {};
    
    Object.entries(edges).forEach(([key, amt]) => {
      const [filer, grantee] = key.split('~');
      
      // Forward adjacency
      if (!fwd[filer]) fwd[filer] = [];
      fwd[filer].push(grantee);
      
      // Reverse adjacency
      if (!rev[grantee]) rev[grantee] = [];
      rev[grantee].push(filer);
    });
    
    return { fwd, rev };
  }

  function multiRootBFS(filteredCharities, adjacency) {
    const visited = new Set();
    const allEINs = Object.keys(filteredCharities);

    // Sort them by descending receipt_amt
    let sortedByReceipt = allEINs.slice().sort((a,b) => {
      return filteredCharities[b].receipt_amt - filteredCharities[a].receipt_amt;
    });

    // If user EINS exist in the filtered set, BFS from the largest among them first
    let hasUserEINsInFiltered = activeEINs.filter(x => allEINs.includes(x));
    if (hasUserEINsInFiltered.length > 0) {
      let largestUserEIN = hasUserEINsInFiltered.reduce((best, cur) => {
        if (!best) return cur;
        const bestAmt = filteredCharities[best].receipt_amt;
        const curAmt = filteredCharities[cur].receipt_amt;
        return (curAmt > bestAmt) ? cur : best;
      }, null);

      bfsFromRoot(largestUserEIN, adjacency, visited);
      sortedByReceipt = sortedByReceipt.filter(x => x !== largestUserEIN);
    }

    // If <5 visited, BFS from next-largest
    let idx = 0;
    while (visited.size < 5 && idx < sortedByReceipt.length) {
      const candidate = sortedByReceipt[idx];
      if (!visited.has(candidate)) {
        bfsFromRoot(candidate, adjacency, visited);
      }
      idx++;
    }

    return visited;
  }

  function bfsFromRoot(root, adjacency, visited) {
    if (!root) return;
    
    // Forward BFS
    let queue = [root];
    const localFwd = new Set();
    while (queue.length > 0 && localFwd.size < BFS_CAP) {
      const curr = queue.shift();
      if (!localFwd.has(curr)) {
        localFwd.add(curr);
        const neighs = adjacency.fwd[curr] || [];
        for (let n of neighs) {
          if (!localFwd.has(n) && localFwd.size < BFS_CAP) {
            queue.push(n);
          }
        }
      }
    }

    // Reverse BFS
    const localRev = new Set();
    queue = [root];
    while (queue.length > 0 && localRev.size < BFS_CAP) {
      const curr = queue.shift();
      if (!localRev.has(curr)) {
        localRev.add(curr);
        const neighs = adjacency.rev[curr] || [];
        for (let n of neighs) {
          if (!localRev.has(n) && localRev.size < BFS_CAP) {
            queue.push(n);
          }
        }
      }
    }

    // Union
    for (let x of localFwd) visited.add(x);
    for (let x of localRev) visited.add(x);
  }

  // Add these helper functions before generateGraph()

  function getNodeWidth(d) {
    // Fixed width with reduced horizontal padding
    return 400; // Back to original width
  }

  function getNodeHeight(d) {
    const charity = charities[d.id];
    // Base height is 160px, plus alert height (30px) if needed, plus bottom padding
    const baseHeight = 160;
    const alertHeight = charity.govt_amt > 10000000 ? 30 : 0;
    const alertMargin = charity.govt_amt > 10000000 ? 15 : 0; // Add margin if there's an alert
    const bottomPadding = 15;
    return baseHeight + alertHeight + alertMargin + bottomPadding;
  }

  function getNodeColor(d) {
    const charity = charities[d.id];
    if (charity.govt_amt > 10000000) return '#FEE2E2'; // red-100
    if (charity.govt_amt > 1000000) return '#FEF3C7';  // amber-100
    return '#F3F4F6'; // gray-100
  }

  function getNodeStroke(d) {
    const charity = charities[d.id];
    if (charity.govt_amt > 10000000) return '#DC2626'; // red-600
    if (charity.govt_amt > 1000000) return '#D97706';  // amber-600
    return '#94A3B8'; // gray-400
  }

  function isUserEin(ein) {
    return activeEINs.includes(ein);
  }

  function formatNumber(x) {
    return (parseInt(x, 10) || 0).toLocaleString('en-US');
  }

  // Update the force simulation parameters to scale with node count
  function getForceParameters(nodes, width, height) {
    const nodeCount = nodes.length;
    const isMobile = width < 768; // Check if we're on mobile
    
    // Scale up distances and forces based on node count
    const baseDistance = isMobile ? 800 : 600; // Increase base distance on mobile
    const distanceScale = Math.min(2, 1 + (nodeCount / 20)); // Increase up to 2x for large graphs
    
    // Scale the viewport bounds based on node count
    const boundaryScale = Math.min(isMobile ? 4 : 3, 1 + (nodeCount / (isMobile ? 10 : 15))); // Larger bounds on mobile
    
    return {
      linkDistance: baseDistance * distanceScale,
      charge: isMobile ? -7000 * distanceScale : -5000 * distanceScale, // Stronger repulsion on mobile
      collisionRadius: (isMobile ? 300 : 250) * Math.sqrt(distanceScale), // Larger collision radius on mobile
      bounds: {
        left: -width * boundaryScale / 2,
        right: width * boundaryScale,
        top: -height * boundaryScale / 2,
        bottom: height * boundaryScale
      },
      // Reduce force strengths for larger graphs to prevent excessive movement
      centerStrength: (isMobile ? 0.01 : 0.02) / Math.sqrt(distanceScale),
      xStrength: (isMobile ? 0.005 : 0.01) / Math.sqrt(distanceScale),
      yStrength: (isMobile ? 0.005 : 0.01) / Math.sqrt(distanceScale)
    };
  }

  // Helper function to measure text width
  function getTextWidth(text, font) {
    const canvas = document.createElement('canvas');
    const context = canvas.getContext('2d');
    context.font = font;
    return context.measureText(text).width;
  }

  // Define search handler functions
  function handleSearch(e) {
    const value = e.target.value.toLowerCase();
    const clearButton = document.getElementById('clearSearch');
    
    // Show/hide clear button based on input value
    if (!value) {
      clearButton.classList.add('hidden');
    } else {
      clearButton.classList.remove('hidden');
    }

    // Get all nodes and filter them if there's a search value
    const allNodes = Array.from(nodeElements.data());
    const matches = value ? allNodes.filter(d => {
      const charity = charities[d.id];
      return charity.name.toLowerCase().includes(value) ||
             d.id.includes(value);
    }) : allNodes;

    showSearchResults(matches);
  }

  // New helper function to show search results
  function showSearchResults(matches) {
    const searchResults = document.getElementById('searchResults');
    
    if (matches.length > 0) {
      // Update search results list
      searchResults.innerHTML = matches
        .map((d, index) => {
          const charity = charities[d.id];
          // Add siren emoji if govt_amt > 10M
          const warningEmoji = charity.govt_amt > 10000000 ? ' ðŸš¨' : '';
          return `
            <div 
              class="px-2 py-1 text-sm cursor-pointer ${index === 0 ? 'bg-blue/10' : ''} hover:bg-gray-100" 
              data-ein="${d.id}"
              data-index="${index}"
              onmouseenter="handleSearchResultHover(${index})"
            >
              ${charity.name}${warningEmoji}
            </div>
          `;
        })
        .join('');
      searchResults.classList.remove('hidden');
      selectedSearchIndex = 0;
      
      // Ensure first result is highlighted
      const firstResult = searchResults.querySelector('[data-index="0"]');
      if (firstResult) {
        firstResult.classList.add('bg-blue/10');
        firstResult.classList.remove('hover:bg-gray-100');
      }
    } else {
      searchResults.classList.add('hidden');
      selectedSearchIndex = -1;
    }
  }

  // Update handleSearchBlur to use a timeout
  function handleSearchBlur(e) {
    // Add a small delay to allow click events to fire first
    setTimeout(() => {
      const searchResults = document.getElementById('searchResults');
      const searchInput = document.getElementById('searchInput');
      
      // Only hide results if we're not clicking inside the results
      if (!searchResults.contains(document.activeElement)) {
        searchResults.classList.add('hidden');
        
        // Reset node highlighting if search is empty
        if (!searchInput.value) {
          nodeElements.select('rect')
            .attr('stroke', n => getNodeStroke(n))
            .attr('stroke-width', n => isUserEin(n.id) ? 3 : 1);
        }
      }
    }, 200);
  }

  function handleSearchClick(e) {
    const ein = e.target.dataset.ein;
    if (!ein) return;

    const searchInput = document.getElementById('searchInput');
    searchInput.value = charities[ein].name;
    document.getElementById('searchResults').classList.add('hidden');

    // Find the clicked node and zoom to it
    const node = d3.select(`g[data-id="${ein}"]`).node();
    if (node) {
      const bounds = node.getBBox();
      const transform = node.getAttribute('transform');
      const translate = transform.match(/translate\(([^)]+)\)/)[1].split(',').map(Number);
      
      const x = translate[0];
      const y = translate[1];
      const width = bounds.width;
      const height = bounds.height;
      
      const containerWidth = document.getElementById('graph-container').offsetWidth;
      const containerHeight = document.getElementById('graph-container').offsetHeight;
      
      // Calculate scale to show the node at about 1/2 of the container (increased from 1/3)
      const scale = 0.45 * Math.min(  // Increased from 0.3 to 0.45 (50% more zoom)
        containerWidth / width,
        containerHeight / height
      );
      
      // Zoom to the node with padding
      d3.select('#graph').transition()
        .duration(750)
        .call(zoom.transform,
          d3.zoomIdentity
            .translate(containerWidth/2, containerHeight/2)
            .scale(scale)
            .translate(-(x + width/2), -(y + height/2))
        );
      
      // Highlight the selected node
      nodeElements.select('rect')
        .attr('stroke', n => n.id === ein ? '#2563EB' : getNodeStroke(n))
        .attr('stroke-width', n => n.id === ein ? 3 : (isUserEin(n.id) ? 3 : 1));
    }
  }

  function handleSearchKeydown(e) {
    const searchResults = document.getElementById('searchResults');
    if (searchResults.classList.contains('hidden')) return;
    
    const results = searchResults.querySelectorAll('[data-index]');
    const maxIndex = results.length - 1;

    if (maxIndex < 0) {
      selectedSearchIndex = -1;
      return;
    }

    switch (e.key) {
      case 'ArrowDown':
        e.preventDefault();
        selectedSearchIndex = Math.min(selectedSearchIndex + 1, maxIndex);
        updateSearchSelection(results);
        break;

      case 'ArrowUp':
        e.preventDefault();
        selectedSearchIndex = Math.max(selectedSearchIndex - 1, 0);
        updateSearchSelection(results);
        break;

      case 'Enter':
        e.preventDefault();
        if (selectedSearchIndex >= 0) {
          const selectedResult = results[selectedSearchIndex];
          if (selectedResult) {
            const ein = selectedResult.dataset.ein;
            handleSearchClick({ target: selectedResult });
          }
        }
        break;

      case 'Escape':
        e.preventDefault();
        searchResults.classList.add('hidden');
        e.target.blur();
        break;
    }
  }

  function updateSearchSelection(results) {
    results.forEach((result, index) => {
      if (index === selectedSearchIndex) {
        result.classList.add('bg-blue/10');
        result.classList.remove('hover:bg-gray-100');
        // Ensure selected item is visible with smooth scrolling
        result.scrollIntoView({ block: 'nearest', behavior: 'smooth' });
      } else {
        result.classList.remove('bg-blue/10');
        result.classList.add('hover:bg-gray-100');
      }
    });
  }

  function handleSearchResultHover(index) {
    selectedSearchIndex = index;
    updateSearchSelection(document.querySelectorAll('[data-index]'));
  }

  // Add this helper function to calculate safe connection points
  function getSafeConnectionPoint(x, y, width, height, side) {
    const cornerPadding = 30;
    const edgeInset = 40;
    
    switch(side) {
      case 'top':
        return {
          x: x + width/2,
          y: y  // Connect exactly at top edge
        };
      case 'bottom':
        return {
          x: x + width/2,
          y: y + height  // Connect exactly at bottom edge
        };
      case 'left':
        return {
          x: x,  // Connect exactly at left edge
          y: y + height/2
        };
      case 'right':
        return {
          x: x + width,  // Connect exactly at right edge
          y: y + height/2
        };
    }
  }

  // Update the orthogonal path generator to ensure better connections
  function generateOrthogonalPath(sourcePoint, targetPoint, sourceSide, targetSide, connectionIndex = 0, totalConnections = 1) {
    // Calculate path parameters
    const dx = targetPoint.x - sourcePoint.x;
    const dy = targetPoint.y - sourcePoint.y;
    
    // Add variation for multiple connections between the same points
    const variation = totalConnections > 1 ? 
      (connectionIndex - (totalConnections-1)/2) * 30 : 0;
    
    // Create points for an orthogonal path
    let path = `M ${sourcePoint.x},${sourcePoint.y}`;
    
    // Check if points are very close (could cause rendering issues)
    const closeThreshold = 10; // pixels
    const isClose = Math.abs(dx) < closeThreshold || Math.abs(dy) < closeThreshold;
    
    // Different path logic based on which sides we're connecting
    if ((sourceSide === 'right' && targetSide === 'left') || 
        (sourceSide === 'left' && targetSide === 'right')) {
      // Horizontal connection (left to right or right to left)
      
      // Check if the target is directly aligned with the source
      if (Math.abs(sourcePoint.y - targetPoint.y) < closeThreshold) {
        // Direct horizontal connection
        path += ` L ${targetPoint.x},${targetPoint.y}`;
      } else {
        const midX = sourcePoint.x + dx/2;
        path += ` L ${midX},${sourcePoint.y}`;
        path += ` L ${midX},${targetPoint.y}`;
        path += ` L ${targetPoint.x},${targetPoint.y}`;
      }
    } 
    else if ((sourceSide === 'top' && targetSide === 'bottom') || 
             (sourceSide === 'bottom' && targetSide === 'top')) {
      // Vertical connection (top to bottom or bottom to top)
      
      // Check if the target is directly aligned with the source
      if (Math.abs(sourcePoint.x - targetPoint.x) < closeThreshold) {
        // Direct vertical connection
        path += ` L ${targetPoint.x},${targetPoint.y}`;
      } else {
        const midY = sourcePoint.y + dy/2;
        path += ` L ${sourcePoint.x},${midY}`;
        path += ` L ${targetPoint.x},${midY}`;
        path += ` L ${targetPoint.x},${targetPoint.y}`;
      }
    }
    else {
      // Mixed sides (e.g., right to top, left to bottom, etc.)
      // Use a three-segment path for better connections
      
      // Determine the extension distances
      const extensionX = Math.min(Math.abs(dx) * 0.3, 60);
      const extensionY = Math.min(Math.abs(dy) * 0.3, 60);
      
      if (sourceSide === 'right' || sourceSide === 'left') {
        // First horizontal, then vertical, then horizontal
        const sign = sourceSide === 'right' ? 1 : -1;
        const midX1 = sourcePoint.x + (sign * extensionX);
        
        path += ` L ${midX1},${sourcePoint.y}`; // First horizontal segment
        path += ` L ${midX1},${targetPoint.y}`; // Vertical segment
        path += ` L ${targetPoint.x},${targetPoint.y}`; // Final horizontal to target
      } else {
        // First vertical, then horizontal, then vertical
        const sign = sourceSide === 'bottom' ? 1 : -1;
        const midY1 = sourcePoint.y + (sign * extensionY);
        
        path += ` L ${sourcePoint.x},${midY1}`; // First vertical segment
        path += ` L ${targetPoint.x},${midY1}`; // Horizontal segment
        path += ` L ${targetPoint.x},${targetPoint.y}`; // Final vertical to target
      }
    }
    
    return path;
  }

  // Update the marker positions to be more visible along the straight segments
  // Source arrow (normal) - moved further along the path
  defs.append('marker')
    .attr('id', 'arrow-source')
    .attr('viewBox', '0 -5 10 10')
    .attr('refX', 30) // Increased from 15 to 30 to move further along the path
    .attr('refY', 0)
    .attr('markerWidth', 10) // Slightly larger markers
    .attr('markerHeight', 10)
    .attr('orient', 'auto')
    .append('path')
    .attr('d', 'M0,-5L10,0L0,5')
    .attr('fill', '#CBD5E1');

  // Source arrow (hover) - moved further along the path
  defs.append('marker')
    .attr('id', 'arrow-source-hover')
    .attr('viewBox', '0 -5 10 10')
    .attr('refX', 30) // Increased from 15 to 30
    .attr('refY', 0)
    .attr('markerWidth', 10)
    .attr('markerHeight', 10)
    .attr('orient', 'auto')
    .append('path')
    .attr('d', 'M0,-5L10,0L0,5')
    .attr('fill', '#2563EB');

  // Target arrow (normal) - moved further from target node
  defs.append('marker')
    .attr('id', 'arrow-target')
    .attr('viewBox', '0 -5 10 10')
    .attr('refX', 35) // Increased from 25 to 35
    .attr('refY', 0)
    .attr('markerWidth', 10)
    .attr('markerHeight', 10)
    .attr('orient', 'auto')
    .append('path')
    .attr('d', 'M0,-5L10,0L0,5')
    .attr('fill', '#CBD5E1');

  // Target arrow (hover) - moved further from target node
  defs.append('marker')
    .attr('id', 'arrow-target-hover')
    .attr('viewBox', '0 -5 10 10')
    .attr('refX', 35) // Increased from 25 to 35
    .attr('refY', 0)
    .attr('markerWidth', 10)
    .attr('markerHeight', 10)
    .attr('orient', 'auto')
    .append('path')
    .attr('d', 'M0,-5L10,0L0,5')
    .attr('fill', '#2563EB');

  // Add this helper function
  function zoomToFitNodes(node1, node2) {
    // Get the bounding boxes of both nodes
    const node1El = nodeElements.filter(n => n.id === node1.id).node();
    const node2El = nodeElements.filter(n => n.id === node2.id).node();
    
    if (!node1El || !node2El) return;
    
    const box1 = node1El.getBBox();
    const box2 = node2El.getBBox();
    
    // Calculate the combined bounds
    const x1 = Math.min(node1.x - box1.width/2, node2.x - box2.width/2);
    const y1 = Math.min(node1.y - box1.height/2, node2.y - box2.height/2);
    const x2 = Math.max(node1.x + box1.width/2, node2.x + box2.width/2);
    const y2 = Math.max(node1.y + box1.height/2, node2.y + box2.height/2);
    
    // Reduce padding from 100 to 50
    const padding = 50;
    const bounds = {
      x: x1 - padding,
      y: y1 - padding,
      width: (x2 - x1) + (padding * 2),
      height: (y2 - y1) + (padding * 2)
    };
    
    // Calculate the scale to fit the bounds
    const scale = 0.9 / Math.max(
      bounds.width / width,
      bounds.height / height
    );
    
    // Transition to the new view
    svg.transition()
      .duration(750)
      .call(zoom.transform,
        d3.zoomIdentity
          .translate(width/2, height/2)
          .scale(scale)
          .translate(
            -(bounds.x + bounds.width/2),
            -(bounds.y + bounds.height/2)
          )
      );
  }

  // Add click handlers to both the line and label
  linkElements.select('.link-hover')
    .on('click', function(event, d) {
      zoomToFitNodes(d.source, d.target);
    });

  // Add to the label background click handler
  linkLabels.select('.label-bg')
    .on('click', function(event, d) {
      zoomToFitNodes(d.source, d.target);
    });

  // Add to the label text click handler
  linkLabels.select('.link-label')
    .on('click', function(event, d) {
      zoomToFitNodes(d.source, d.target);
    });

  // Fix the syntax error by placing the debug code correctly within the generateGraph function
  // This should go right after we create the link elements, inside the generateGraph function

  // Add console logs to check marker setup
  console.log('Marker IDs:', Array.from(document.querySelectorAll('defs marker')).map(m => m.id));
  console.log('Link elements with markers:', document.querySelectorAll('.link[marker-end]').length);

  // Remove the arrowPaths since we're now using markers
  // This should properly remove the duplicate arrows
  arrowPaths.remove();

  // Remove the illegal return statement and conditional at the bottom of the file (lines 3008-3022)
  // That code is already properly integrated in the tick function for handling self-loops

  // After logging the marker IDs and right before the end of the generateGraph function
  // Add this code in the correct context

  // Move the arrowPaths removal code to the generateGraph function
  // This should be after we've confirmed the markers are working
  console.log('Removing redundant arrow paths...');
  linkElements.selectAll('.arrow-path').remove();

  // We should also update any mouseover/mouseout handlers that might reference arrowPaths
  // by ensuring we're only updating the .link elements

  // Add back the getSpacedConnectionPoint function that was accidentally removed

  // Update the connection point spacing logic to spread points along node height/width
  function getSpacedConnectionPoint(node, connections, index, side, totalWidth) {
    const nodeWidth = getNodeWidth(node);
    const nodeHeight = getNodeHeight(node);
    const padding = 40; // Padding from edges
    
    // If no connections, use the center of the side
    if (connections.length === 0) {
      index = 0;
      connections = [null]; // Create a dummy array with one element
    }
    
    // Calculate usable dimensions for connection points
    const usableWidth = nodeWidth - (padding * 2);
    const usableHeight = nodeHeight - (padding * 2);
    
    if (side === 'top' || side === 'bottom') {
      // Spread points horizontally along top/bottom
      const horizontalSpacing = usableWidth / (connections.length + 1);
      const x = node.x - (nodeWidth/2) + padding + ((index + 1) * horizontalSpacing);
      
      return {
        x: x,
        y: node.y + (side === 'top' ? -nodeHeight/2 : nodeHeight/2)
      };
    } else {
      // For left/right sides, spread vertically
      const verticalSpacing = usableHeight / (connections.length + 1);
      const y = node.y - (nodeHeight/2) + padding + ((index + 1) * verticalSpacing);
      
      return {
        x: node.x + (side === 'left' ? -nodeWidth/2 : nodeWidth/2),
        y: y
      };
    }
  }
</script>
