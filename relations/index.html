---
layout: default
title: People Relations (BETA)
---

{% include search-metadata.html base_title="People Relations" base_url="https://datarepublican.com/relations/" search_id="graphTitle" param_names='["subject", "search"]' %}

<!-- Custom override for updateSearchMetadata to omit "Search results for" text -->
<script>
  // Store the original function
  const originalUpdateSearchMetadata = window.updateSearchMetadata;
  
  // Override with our custom version
  window.updateSearchMetadata = function(params, baseTitle, baseUrl, searchId) {
    const paramNames = JSON.parse('["subject", "search"]');
    let searchTerms = [];
    let canonicalUrl = baseUrl;
    
    // Extract search terms from URL parameters
    for (const param of paramNames) {
      const value = params.get(param);
      if (value) {
        searchTerms.push(value);
        canonicalUrl += (canonicalUrl.includes('?') ? '&' : '?') + param + '=' + encodeURIComponent(value);
      }
    }
    
    // Handle EINs and keywords specifically
    if (params.get('eins')) {
      const eins = params.get('eins').split(',');
      if (eins.length > 0) {
        searchTerms.push('EINs: ' + eins.join(', '));
        canonicalUrl += (canonicalUrl.includes('?') ? '&' : '?') + 'eins=' + encodeURIComponent(params.get('eins'));
      }
    }
    
    if (params.get('keywords')) {
      const keywords = params.get('keywords').split(',');
      if (keywords.length > 0) {
        searchTerms.push('Keywords: ' + keywords.join(', '));
        canonicalUrl += (canonicalUrl.includes('?') ? '&' : '?') + 'keywords=' + encodeURIComponent(params.get('keywords'));
      }
    }
    
    // Update page title and metadata if we have search terms
    if (searchTerms.length > 0) {
      const searchTermsStr = searchTerms.join(', ');
      const pageTitle = `${searchTermsStr} - ${baseTitle}`;
      
      // Update the H1 with just the search term (no "Search results for" text)
      const titleElement = document.getElementById(searchId);
      if (titleElement) {
        titleElement.textContent = searchTermsStr;
      }
      
      // Update document title
      document.title = pageTitle;
      
      // Update JSON-LD metadata
      const metadata = {
        "@context": "https://schema.org",
        "@type": "WebPage",
        "name": pageTitle,
        "url": canonicalUrl
      };
      
      // Add or update JSON-LD
      let jsonLd = document.getElementById('searchMetadata');
      if (!jsonLd) {
        jsonLd = document.createElement('script');
        jsonLd.id = 'searchMetadata';
        jsonLd.type = 'application/ld+json';
        document.head.appendChild(jsonLd);
      }
      jsonLd.textContent = JSON.stringify(metadata);
      
      // Add or update canonical link
      let canonicalLink = document.querySelector('link[rel="canonical"]');
      if (!canonicalLink) {
        canonicalLink = document.createElement('link');
        canonicalLink.rel = 'canonical';
        document.head.appendChild(canonicalLink);
      }
      canonicalLink.href = canonicalUrl;
    }
  };
</script>

<!-- jQuery for convenience -->
<script src="jquery.min.js"></script>

<!-- Viz.js (core + full render) -->
<!-- <script src="viz.js"></script>
<script src="full.render.js"></script> -->

<!-- Cytoscape.js for modern graph visualization -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/cytoscape/3.26.0/cytoscape.min.js"></script>

<!-- svg-pan-zoom for panning/zooming the resulting SVG -->
<!-- <script src="svg-pan-zoom.min.js"></script> -->

<!-- JSZip for reading zipped CSVs -->
<script src="jszip.min.js"></script>

<!-- Papa Parse for CSV parsing -->
<script src="papaparse.min.js"></script>

<script src="murmurHash3.js"></script>

<style>

  .shidden { display: none; }

  .loading-spinner {
    vertical-align: middle;
  }
  #graph-container {
    width: 100%;
    height: 80vh;      /* or calc(100vh - someOffset) */
    position: relative;
    overflow: hidden;  /* if you like; up to you */
  }
  #legend {
    display: flex;
    align-items: flex-start;
    flex-wrap: wrap;
    gap: 8px;
    margin-bottom: 0.5rem;
  }
  .legend-item {
    padding: 4px 8px;
    border-radius: 4px;
    font-size: 12px;
    font-weight: bold;
    color: white;
    cursor: pointer;
    transition: opacity 0.2s;
  }
  .legend-item.disabled {
    opacity: 0.5;
  }
  /* Category colors */
  .legend-FAMILY { background-color: #E11D48; }
  .legend-WORK { background-color: #2563EB; }
  .legend-POLITICAL { background-color: #9333EA; }
  .legend-LEGAL { background-color: #DC2626; }
  .legend-MEDIA { background-color: #EA580C; }
  .legend-EDUCATION { background-color: #4ADE80; }
  .legend-HISTORICAL { background-color: #D97706; }
  .legend-SOCIAL { background-color: #14B8A6; }
  .legend-OTHER { background-color: #6B7280; }
  .legend-UNKNOWN { background-color: #6B7280; }
  
  /* Special styling for reset button */
  #reset-view {
    font-size: 16px;
  }
  
  /* Node tooltip styles */
  .cy-tooltip {
    position: absolute;
    z-index: 1000;
    background: white;
    border: 1px solid #ccc;
    border-radius: 4px;
    padding: 8px;
    max-width: 300px;
    box-shadow: 0 2px 8px rgba(0,0,0,0.2);
    pointer-events: none;
    font-size: 12px;
    opacity: 0;
    transition: opacity 0.2s;
    line-height: 1.4;
  }

  /* Node styling */
  #cy node {
    text-wrap: wrap;
    text-max-width: 180px;
    text-overflow: ellipsis;
    border-width: 1px;
    font-size: 13px;
    min-width: 50px;
    min-height: 50px;
    font-family: "Libre Franklin", -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
  }
  
  /* Custom CSS for node text styling */
  .cy-node-label {
    font-weight: bold;
  }
  
  .cy-node-description {
    font-weight: normal;
    font-size: 12px;
  }
  
  #loading-indicator {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    z-index: 100;
  }
</style>

<!-- 
=========================
======== SEARCH UI ======
=========================

This container is displayed in "Search Mode" (no ?subject= in the URL),
letting the user enter a name, see results, and click to load GraphViz mode.
-->

<div id="searchMode" class="mb-4 shidden">
<h1 class="mb-1">People &amp; relationships lookup</h1>
<p class="text-sm mb-3">
  Search for a name or phrase. We'll do an inclusive search (all tokens must appear).
  Each matching subject is displayed along with a quick description. Click on a name to load its relationship graph.
</p>

<div id="searchFormWrapper" class="mb-4">
  <form id="searchForm" class="flex flex-wrap gap-2 items-end">
    <div>
      <label for="searchBox" class="text-sm font-bold mb-1">Name/Keyword(s)</label><br/>
      <input type="text" id="searchBox" class="border border-gray-200 rounded p-2 w-full" placeholder="E.g. 'aaron' or '14th Dalai Lama'"/>
    </div>

    <button type="submit" id="searchButton" class="p-2 border border-gray-200 rounded font-bold text-sm">
      <span class="button-text">Search</span>
      <img src="../assets/images/loading-white.svg" class="loading-spinner" style="display:none;width:16px;height:16px" alt="Loading..."/>
    </button>

    <div class="relative -top-1">
      <input type="checkbox" id="prefixCheck"/>
      <label for="prefixCheck" class="text-sm">Use prefix matching</label>
    </div>

    <span id="statusMessage" class="text-sm"></span>
  </form>
</div>

<div id="resultsContainer" class="flex flex-col gap-2"></div>
<div id="resultsStatus" class="mt-2 text-sm"></div>
</div>

<!-- 
===============================
======== GRAPHVIZ UI =========
===============================

This container is displayed in "GraphViz Mode" (when ?subject= is in the URL, or after user clicks on a result).
It shows the generated graph and a legend, plus a button to go back to the search mode.
-->

<div id="graphMode" class="shidden">
<button id="backToSearch" class=" frameless !mb-2">&larr; Return to search</button>

<div id="graphExplanation" class="mb-3">
  <h1 id="graphTitle" class="mb-1">Relationship graph</h1>

  <p class="text-sm mb-0">Hover a node to trace its connections. Zoom with your mouse or trackpad. Click and drag to move it around for better legibility.</p>
</div>

<strong class="text-sm font-semibold mb-1 inline-block">Categories</strong>
<!-- Legend for edge categories -->
<div id="legend"></div>

<!-- A spot to show short summary about the root subject from bullets.csv -->
<ul id="rootSummary" class="mb-4 p-2 md:px-4 !pl-8 !pb-4 md:pt-3 border rounded text-sm bg-white list-disc"></ul>

<div class="relative">
  <div class="absolute top-3 right-3 z-10">
    <button id="downloadBtn" class="frameless !px-2 !py-1 border !border-solid border-transparent hover:border-gray-200 rounded !bg-white/75 backdrop-blur" style="display: none;">Download PNG</button>
  </div>
  <!-- Where the graph renders -->
  <div id="graph-container" class="border rounded flex items-center justify-center bg-white">
    <div id="cy" style="width: 100%; height: 100%;"></div>
    <div id="cy-controls" class="absolute bottom-4 right-4 z-10 flex flex-col gap-1">
      <button class="p-2 rounded min-w-0 mr-0 bg-black/60 hover:bg-black" id="zoom-in" title="Zoom in">
        <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6v6m0 0v6m0-6h6m-6 0H6"/>
        </svg>
      </button>
      <button class="p-2 rounded min-w-0 mr-0 bg-black/60 hover:bg-black" id="zoom-out" title="Zoom out">
        <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M20 12H4"/>
        </svg>
      </button>
      <button class="p-2 rounded min-w-0 mr-0 bg-black/60 hover:bg-black" id="reset-view" title="Reset view">
        <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 8V4m0 0h4M4 4l5 5m11-5V4m0 0h-4m4 0l-5 5M4 16v4m0 0h4m-4 0l5-5m11 5v-4m0 4h-4m4 0l-5-5"/>
        </svg>
      </button>
      <!--
      <button class="p-2 rounded min-w-0 mr-0 bg-black/60 hover:bg-black" id="toggle-labels" title="Toggle edge labels">L</button>
      <button class="p-2 rounded min-w-0 mr-0 bg-black/60 hover:bg-black" id="toggle-secondary" title="Show only root connections">R</button>
      -->
    </div>
    <div class="cy-tooltip"></div>
    <div id="loading-indicator">
      <img src="../assets/images/loading.svg" class="loading-spinner" style="width:32px;height:32px" alt="Loading...">
    </div>
  </div>
</div>

</div>


<script>
/***************************************
* GLOBALS
***************************************/
let allReverseIndex = new Map();      // token -> array of lineIDs (with ranges)
let allSubjects = [];                 // lines from subjects.csv (index = line-1)
let allBullets = new Map();           // subject -> { bullet_point1, bullet_point2 }
let searchInProgress = false;
let searchCanceled = false;
let hasInitialDataLoaded = false;
let safeRootId = null;                // Store the safe ID of the root node globally

// Debug log to verify script is loading
console.log("Graph script loaded - " + new Date().toISOString());

// For debugging - add this to window to access from console
window.debugNodeStyling = function() {
  console.log("Manual debug triggered");
  fixNodeStyling();
};

// For Graph Mode
const NUM_PARTITIONS = 47;           
let categoryColors = {               
  "FAMILY": "#E11D48",
  "WORK": "#2563EB",
  "POLITICAL": "#9333EA",
  "LEGAL": "#DC2626",
  "MEDIA": "#EA580C",
  "EDUCATION": "#4ADE80",
  "HISTORICAL": "#D97706",
  "SOCIAL": "#14B8A6",
  "OTHER": "#6B7280",
  "UNKNOWN": "#6B7280"
};

let panZoomInstance = null;

// We store all graph edges in memory so toggling categories is easy:
let globalNodesMap = new Map();  // subject -> bullet info
let globalAllEdges = [];         // all edges (including duplicates filtered out)
let globalActiveCategories = new Set(); // which categories are currently on display


/***************************************
* ON LOAD
***************************************/
$(document).ready(async function() {
  // Check if we have a ?subject= param
  const urlParams = new URLSearchParams(window.location.search);
  const subj = urlParams.get('subject');
  const searchParam = urlParams.get('search');

  // Initialize metadata based on URL parameters
  if (subj || searchParam) {
    const baseUrl = window.location.hostname.includes('localhost') ? 
      "http://localhost:4000/relations/" : 
      "https://datarepublican.com/relations/";
    updateSearchMetadata(urlParams, "People Relations", baseUrl, "graphTitle");
  }

  // Show/hide respective modes
  if (subj) {
    $('#graphMode').removeClass('shidden');
  } else {
    $('#searchMode').removeClass('shidden');
  }

  // Start loading data in background
  await loadInitialData();

  // If we have ?subject=, go straight to GraphViz mode after data loads
  if (subj) {
    renderGraphForSubject(subj);
  }

  // Otherwise, remain in search mode, but if the user typed any text in ?search= param, do that:
  if (!subj && searchParam) {
    $('#searchBox').val(searchParam);
    $('#searchForm').trigger('submit');
  }
});


/***************************************
* Load initial data: reverse_index, subjects.csv, bullets.csv
***************************************/
async function loadInitialData() {
  if (hasInitialDataLoaded) return;
  $('#statusMessage').text('Loading data...');

  try {
    // Show spinner
    $('#searchButton .button-text').hide();
    $('#searchButton .loading-spinner').show();
    $('#searchButton').prop('disabled', true);

    // 1) Load reverse_index.txt
    await loadReverseIndex("reverse_index.txt");

    // 2) Load subjects.csv (from subjects.csv.zip)
    await loadSubjectsCSV("subjects.csv.zip", "subjects.csv");

    // 3) Load bullets.csv (from bullets.csv.zip)
    await loadBulletsCSV("bullets.csv.zip", "bullets.csv");

    hasInitialDataLoaded = true;
    $('#statusMessage').empty();
  } catch (err) {
    console.error(err);
    $('#statusMessage').text("Error: " + err);
  } finally {
    // Hide spinner
    $('#searchButton .loading-spinner').hide();
    $('#searchButton .button-text').show();
    $('#searchButton').prop('disabled', false);
  }
}

async function loadReverseIndex(txtUrl) {
  // If it's zipped, do fetch -> JSZip -> read string. 
  // For demo, assume it's just "reverse_index.txt".
  const resp = await fetch(txtUrl);
  if (!resp.ok) throw new Error(`Could not fetch ${txtUrl}`);
  const text = await resp.text();

  // parse lines like "aaron:75-110,6194,8048,13186,20098,34603"
  const lines = text.split(/\r?\n/);
  for (let line of lines) {
    line = line.trim();
    if (!line) continue;
    const parts = line.split(':');
    if (parts.length !== 2) continue;
    const token = parts[0];
    const ranges = parts[1].split(',');

    let lineIDs = [];
    for (let r of ranges) {
      if (r.includes('-')) {
        const [start, end] = r.split('-').map(x=>parseInt(x,10));
        for (let i=start; i<=end; i++) {
          lineIDs.push(i);
        }
      } else {
        let val = parseInt(r, 10);
        if (!isNaN(val)) {
          lineIDs.push(val);
        }
      }
    }
    if (!allReverseIndex.has(token)) {
      allReverseIndex.set(token, []);
    }
    allReverseIndex.get(token).push(...lineIDs);
  }
}

async function loadSubjectsCSV(zipUrl, csvFile) {
  const resp = await fetch(zipUrl);
  if (!resp.ok) throw new Error('Could not fetch ' + zipUrl);
  const buffer = await resp.arrayBuffer();

  const z = await JSZip.loadAsync(buffer);
  if (!z.file(csvFile)) throw new Error(`Missing file ${csvFile} in zip.`);

  const csvData = await z.file(csvFile).async('string');
  const parsed = Papa.parse(csvData, {
    header: true,
    skipEmptyLines: true
  });
  allSubjects = parsed.data; 
}

async function loadBulletsCSV(zipUrl, csvFile) {
  const resp = await fetch(zipUrl);
  if (!resp.ok) throw new Error('Could not fetch ' + zipUrl);
  const buffer = await resp.arrayBuffer();

  const z = await JSZip.loadAsync(buffer);
  if (!z.file(csvFile)) throw new Error(`Missing file ${csvFile} in zip.`);

  const csvData = await z.file(csvFile).async('string');
  const parsed = Papa.parse(csvData, {
    header: true,
    skipEmptyLines: true
  });

  for (let row of parsed.data) {
    const s = row['subject']?.trim() ?? '';
    if (!s) continue;
    allBullets.set(s, {
      bullet_point1: row['bullet_point1'] || '',
      bullet_point2: row['bullet_point2'] || ''
    });
  }
}


/***************************************
* SEARCH FORM
***************************************/
$('#searchForm').on('submit', async function(e) {
  e.preventDefault();
  if (searchInProgress) {
    // If in progress, let user cancel
    searchCanceled = true;
    return;
  }
  searchCanceled = false;
  searchInProgress = true;

  // clear old results
  $('#resultsContainer').empty();
  $('#resultsStatus').empty();

  // show spinner
  $('#searchButton .button-text').text("Stop");
  $('#searchBox').prop('disabled', true);

  try {
    await doSearch();
  } catch (err) {
    console.error(err);
    $('#resultsContainer').html(`<div class="p-2 text-center text-sm text-red-500">Error: ${err}</div>`);
  }

  // restore
  searchInProgress = false;
  $('#searchButton .button-text').text("Search");
  $('#searchBox').prop('disabled', false);
});


async function doSearch() {
  const rawInput = $('#searchBox').val().toLowerCase().trim();
  if (!rawInput) {
    $('#resultsContainer').html('<div class="p-2 text-center text-sm">No input provided.</div>');
    return;
  }

  // update URL param ?search= 
  const newUrl = new URL(window.location);
  newUrl.searchParams.delete('subject');
  newUrl.searchParams.set('search', rawInput);
  window.history.pushState({}, '', newUrl);
  
  // Update metadata for SEO
  const params = new URLSearchParams();
  params.set('search', rawInput);
  const baseUrl = window.location.hostname.includes('localhost') ? 
    "http://localhost:4000/relations/" : 
    "https://datarepublican.com/relations/";
  updateSearchMetadata(params, "People Relations", baseUrl, "graphTitle");

  // tokenize
  let tokens = tokenizeInput(rawInput);

  // intersect sets
  let finalLineSet = null;
  for (let t of tokens) {
    if (searchCanceled) break;

    let linesForT = new Set();
    // exact matches
    if (allReverseIndex.has(t)) {
      for (let ln of allReverseIndex.get(t)) {
        linesForT.add(ln);
      }
    }
    // prefix if box is checked
    if ($('#prefixCheck').is(':checked') && t.length >= 4) {
      // find anything that starts with t
      for (let [kw, lines] of allReverseIndex.entries()) {
        if (kw.startsWith(t) && kw !== t) {
          for (let ln of lines) {
            linesForT.add(ln);
          }
        }
      }
    }

    // intersect
    if (finalLineSet === null) {
      finalLineSet = linesForT;
    } else {
      let tmp = new Set();
      for (let x of finalLineSet) {
        if (linesForT.has(x)) tmp.add(x);
      }
      finalLineSet = tmp;
    }
    if (!finalLineSet.size) break;
  }

  if (!finalLineSet || !finalLineSet.size) {
    $('#resultsContainer').html('<div class="p-2 text-center text-sm">No matches found.</div>');
    return;
  }

  let sortedLines = Array.from(finalLineSet).sort((a,b)=>a-b);
  let limit = 100;
  let displayed = 0;

  for (let ln of sortedLines) {
    if (searchCanceled) break;
    if (displayed >= limit) break;

    let idx = ln - 1;
    if (idx >= 0 && idx < allSubjects.length) {
      let row = allSubjects[idx];
      let subject = row['subject'] || '';
      let desc = row['bullet_point1'] || '';
      $('#resultsContainer').append(renderSearchResult(subject, desc));
      displayed++;
    }
  }

  if (displayed > 0) {
    let extra = searchCanceled ? ' (stopped)' : (displayed === limit ? ' (limit)' : '');
    $('#resultsStatus').text(`Showing ${displayed}${extra} results`);
  } else {
    $('#resultsContainer').html('<div class="p-2 text-center text-sm">No results found.</div>');
  }
}

function tokenizeInput(txt) {
  // remove non-alphanumeric except for ' and "
  txt = txt.replace(/[^\w\s"']+/g, ' ');
  return txt.split(/\s+/).filter(Boolean);
}

function renderSearchResult(subject, desc) {
  const safeSubject = escapeHtml(subject);
  const safeDesc = escapeHtml(desc);

  let $div = $(`
    <div class="group border border-gray-200 hover:border-gray-400 bg-white rounded p-2 md:px-4 leading-tight">
      <strong class="text-navy group-hover:text-blue text-sm">${safeSubject}</strong><br/>
      <span class="text-[13px]">${safeDesc}</span>
    </div>
  `);

  $div.css('cursor','pointer').on('click', function() {
    // Get the current URL and preserve the search parameter
    const currentUrl = new URL(window.location);
    const searchTerm = currentUrl.searchParams.get('search');
    
    // Create the new URL with the subject parameter
    const newUrl = new URL(window.location);
    newUrl.searchParams.set('subject', subject);
    
    // Preserve the search parameter if it exists
    if (searchTerm) {
      newUrl.searchParams.set('search', searchTerm);
    }
    
    window.location.href = newUrl.toString();
  });

  return $div;
}


/***************************************
* BACK TO SEARCH
***************************************/
$('#backToSearch').on('click', function() {
  const newUrl = new URL(window.location);
  newUrl.searchParams.delete('subject');
  window.history.pushState({}, '', newUrl);
  
  // Reset the title to default
  document.title = "People Relations (BETA)";
  
  // Reset canonical URL
  let canonicalLink = document.querySelector('link[rel="canonical"]');
  if (canonicalLink) {
    const baseUrl = window.location.hostname.includes('localhost') ? 
      "http://localhost:4000/relations/" : 
      "https://datarepublican.com/relations/";
    canonicalLink.href = baseUrl;
  }
  
  // Reset JSON-LD metadata
  let jsonLd = document.getElementById('searchMetadata');
  if (jsonLd) {
    jsonLd.textContent = JSON.stringify({
      "@context": "https://schema.org",
      "@type": "WebPage",
      "name": "People Relations (BETA)",
      "url": canonicalLink ? canonicalLink.href : window.location.href
    });
  }
  
  window.location.reload();
});


/***************************************
* GRAPH MODE
***************************************/
async function renderGraphForSubject(subjectName) {
  // Show spinner in #graph-container
  $('#loading-indicator').show();
  $('#cy').empty();
  
  // Make sure download button is hidden while loading
  $('#downloadBtn').hide();

  // Set the search param in the URL while preserving the search parameter
  const newUrl = new URL(window.location);
  const searchTerm = newUrl.searchParams.get('search');
  newUrl.searchParams.set('subject', subjectName);
  
  // Make sure to keep the search parameter if it exists
  if (searchTerm) {
    newUrl.searchParams.set('search', searchTerm);
  }
  
  window.history.pushState({}, '', newUrl);

  // Put subject name in title
  $('#graphTitle').text(subjectName);
  
  // Update metadata for SEO
  const params = new URLSearchParams();
  params.set('subject', subjectName);
  const baseUrl = window.location.hostname.includes('localhost') ? 
    "http://localhost:4000/relations/" : 
    "https://datarepublican.com/relations/";
  updateSearchMetadata(params, "People Relations", baseUrl, "graphTitle");

  // Summarize from bullets.csv if found
  let bulletInfo = allBullets.get(subjectName) || {};
  let b1 = bulletInfo.bullet_point1 || "";
  let b2 = bulletInfo.bullet_point2 || "";
  let summaryHtml = ``;
  if (b1) summaryHtml += `<li class="mb-1">${escapeHtml(b1)}</li>`;
  if (b2) summaryHtml += `<li>${escapeHtml(b2)}</li>`;
  if (!b1 && !b2) {
    summaryHtml += `<li class="text-sm text-gray-600 list-none">(No extended info available.)</li>`;
  }
  $('#rootSummary').html(summaryHtml);

  // Clear globals for new subject
  globalNodesMap.clear();
  globalAllEdges = [];
  globalActiveCategories.clear();

  // Add the root node
  addNodeIfNeeded(globalNodesMap, subjectName);

  // figure out which partition
  const partitionIdx = partitionIndex(subjectName);
  let pStr = partitionIdx.toString().padStart(2,'0');
  const relationsZip = `relations_${pStr}.zip`;

  try {
    const resp = await fetch(relationsZip);
    if (!resp.ok) {
      throw new Error(`Unable to fetch ${relationsZip}`);
    }
    const buffer = await resp.arrayBuffer();
    const z = await JSZip.loadAsync(buffer);

    // parse relations.csv, relations_reverse.csv, intergraph_edges.csv
    const relationsCsv     = await getZipText(z, 'relations.csv');
    const revCsv           = await getZipText(z, 'relations_reverse.csv');
    const interCsv         = await getZipText(z, 'intergraph_edges.csv');

    const parsedRelations  = Papa.parse(relationsCsv,     { header:true, skipEmptyLines:true }).data;
    const parsedReverse    = Papa.parse(revCsv,           { header:true, skipEmptyLines:true }).data;
    const parsedIntergraph = Papa.parse(interCsv,         { header:true, skipEmptyLines:true }).data;

    let edgesSet = new Set(); // to ensure no duplicates

    // 1) Forward edges
    for (let row of parsedRelations) {
      let s = row.subject?.trim() || "";
      if (s !== subjectName) continue;
      let o = (row.object || "").trim();
      if (!o) continue;

      addNodeIfNeeded(globalNodesMap, o);
      let c = row.category?.trim() || "UNKNOWN";
      let color = categoryColors[c] || categoryColors["UNKNOWN"];
      addEdge(edgesSet, globalAllEdges, s, o, (row.label||""), c, color);
    }

    // 2) Reverse edges
    for (let revRow of parsedReverse) {
      let obj = revRow.object?.trim() || "";
      if (obj !== subjectName) continue;

      let s = revRow.subject?.trim() || "";
      if (!s) continue;

      let symmetrical = parseInt(revRow.is_symmetrical,10) === 1;
      if (symmetrical) {
        // skip if forward set had the mirror
        let hasMirror = parsedRelations.some(rel => {
          return (rel.subject?.trim() === subjectName && rel.object?.trim() === s);
        });
        if (hasMirror) continue;
      }
      addNodeIfNeeded(globalNodesMap, s);
      let c = revRow.category?.trim() || "UNKNOWN";
      let color = categoryColors[c] || categoryColors["UNKNOWN"];
      addEdge(edgesSet, globalAllEdges, s, subjectName, (revRow.label||""), c, color);
    }

    // 3) Intergraph edges
    const potentialEdges = [];
    for (let iRow of parsedIntergraph) {
      let rp = iRow.root_person?.trim() || "";
      if (rp !== subjectName) continue;

      let s = iRow.subject?.trim() || "";
      let o = iRow.object?.trim() || "";
      if (!s || !o) continue;

      if (globalNodesMap.has(s) && globalNodesMap.has(o)) {
        potentialEdges.push({
          from: s,
          to: o,
          label: iRow.label || "",
          symmetrical: parseInt(iRow.is_symmetrical,10)===1,
          category: iRow.category?.trim() || "UNKNOWN"
        });
      }
    }
    // Filter symmetrical duplicates
    let finalInterEdges = [];
    for (let pe of potentialEdges) {
      let swapped = potentialEdges.find(e => {
        return (e.from === pe.to && e.to === pe.from && e.symmetrical === true && pe.symmetrical === true);
      });
      if (swapped && pe.from > pe.to) {
        // skip
        continue;
      }
      finalInterEdges.push(pe);
    }
    // Add them
    for (let pe of finalInterEdges) {
      let c = pe.category;
      let color = categoryColors[c] || categoryColors["UNKNOWN"];
      addEdge(edgesSet, globalAllEdges, pe.from, pe.to, pe.label, c, color);
    }

    // Initialize active categories
    let uniqueCats = new Set(globalAllEdges.map(e => e.category));
    for (let c of uniqueCats) {
      globalActiveCategories.add(c);
    }

    // Render the legend
    renderLegend([...uniqueCats]);

    // Build and render final
    reRenderGraph(subjectName);

  } catch (err) {
    console.error(err);
    $('#graph-container').html(
      `<div class="p-2 text-center text-sm text-red-500">Error loading relationships: ${err}</div>`
    );
  }
}

// A function to ensure node exists
function addNodeIfNeeded(map, subject) {
  if (!map.has(subject)) {
    let bullet = allBullets.get(subject) || { bullet_point1:'', bullet_point2:'' };
    map.set(subject, bullet);
  }
}

// Deduplicate edges
function addEdge(edgesSet, edgesArray, from, to, label, category, color) {
  let key = `${from}||${to}||${category}||${label}`;
  if (edgesSet.has(key)) {
    return; // skip duplicates
  }
  edgesSet.add(key);
  edgesArray.push({ from, to, label, category, color });
}

// Partition
function partitionIndex(subj) {
  const h = murmurHash3.x86.hash32(subj);
  return h % NUM_PARTITIONS;
}

async function getZipText(zipObj, filename) {
  if (!zipObj.file(filename)) throw new Error(`Missing ${filename} in zip.`);
  return await zipObj.file(filename).async('string');
}

/***************************************
* DOT BUILDING / RENDERING
***************************************/
// We insert <br> every ~50 chars on word boundaries
function insertLineBreaks(str, maxLen=50) {
  if (!str) return '';
  const words = str.split(/\s+/);
  let lines = [];
  let current = '';

  for (let w of words) {
    if (!current) {
      current = w;
    } else if ((current + ' ' + w).length > maxLen) {
      lines.push(escapeHtml(current));
      current = w;
    } else {
      current += ' ' + w;
    }
  }
  if (current) lines.push(escapeHtml(current));
  return lines.join("<br>");
}

// Convert graph data to Cytoscape.js format
function buildCytoscapeElements(rootSubject, nodesMap, edges) {
  let elements = [];
  
  // Add nodes
  for (let [subj, bulletData] of nodesMap.entries()) {
    let isRoot = subj === rootSubject;
    
    // Create a safe ID by replacing spaces and special characters
    const safeId = subj.replace(/[^a-zA-Z0-9]/g, '_');
    
    const nodeData = {
      id: safeId,
      title: subj,
      description: bulletData.bullet_point1 || "",
      fullName: subj,
      bulletPoint1: bulletData.bullet_point1 || "",
      bulletPoint2: bulletData.bullet_point2 || "",
      isRoot: isRoot
    };
    
    elements.push({
      data: nodeData
    });
  }
  
  // Add edges - use full label without truncation
  for (let e of edges) {
    // Create safe IDs for source and target
    const safeSource = e.from.replace(/[^a-zA-Z0-9]/g, '_');
    const safeTarget = e.to.replace(/[^a-zA-Z0-9]/g, '_');
    
    elements.push({
      data: {
        id: `${safeSource}-${safeTarget}-${e.category}`,
        source: safeSource,
        target: safeTarget,
        label: e.label,  // Use full label
        category: e.category,
        color: e.color,
        isFromRoot: e.from === rootSubject,
        isToRoot: e.to === rootSubject
      }
    });
  }
  
  return elements;
}

// Initialize and render Cytoscape graph
function renderCytoscape(rootSubject, elements) {
  // Hide loading indicator
  $('#loading-indicator').hide();
  
  // Clear previous instance if exists
  if (window.cy) {
    try {
      // Remove the container element and recreate it
      $('#cy').remove();
      $('#graph-container').append('<div id="cy" style="width: 100%; height: 100%;"></div>');
      window.cy = null;
    } catch (e) {
      console.warn("Could not clean up previous Cytoscape instance:", e);
    }
  }
  
  // Create a safe ID for the root subject
  safeRootId = rootSubject.replace(/[^a-zA-Z0-9]/g, '_');
  
  // Create new Cytoscape instance with a delay to ensure DOM is ready
  setTimeout(() => {
    try {
      window.cy = cytoscape({
        container: document.getElementById('cy'),
        elements: elements,
        style: [
          // Node styles
          {
            selector: 'node',
            style: {
              'background-color': '#F3F4F6',
              'border-color': '#94A3B8',
              'border-width': 1,
              'shape': 'round-rectangle',
              'width': function(ele) {
                // Calculate width based on content
                const title = ele.data('title') || ele.id();
                const description = ele.data('description') || "";
                
                // Find the longest word to ensure it fits
                const words = (title + " " + description).split(/\s+/);
                let longestWordLength = 0;
                words.forEach(word => {
                  longestWordLength = Math.max(longestWordLength, word.length);
                });
                
                // Estimate average character width (in pixels) for the font
                const avgCharWidth = 7.5; // Approximate width for 13px font
                
                // Calculate minimum width needed for the longest word
                const minWidthNeeded = longestWordLength * avgCharWidth + 24; // Add padding
                
                // Return at least 180px width or more if needed for long words
                return Math.max(180, minWidthNeeded);
              },
              'height': 40, // Default height for nodes without descriptions
              'padding': 12,  // Consistent padding for all nodes
              'text-wrap': 'wrap',
              'text-max-width': function(ele) {
                // Calculate text max width based on node width
                const nodeWidth = ele.style('width');
                // Convert from string like '180px' to number
                const width = parseInt(nodeWidth, 10);
                // Return width minus padding
                return width - 24;
              },
              'text-valign': 'center',
              'text-halign': 'center',
              'text-margin-y': 0,
              'text-justification': 'center',
              'font-family': '"Libre Franklin", serif',
              'font-size': '13px',
              'color': '#000000',
              'text-outline-width': 0,
              'text-outline-opacity': 0,
              'font-weight': 'normal',
              'text-transform': 'none',
              'label': function(ele) {
                return ele.data('title') || ele.id();
              }
            }
          },
          // Style for nodes with descriptions
          {
            selector: 'node[description]',
            style: {
              'height': function(ele) {
                // Get node width to calculate how many lines the text will take
                const nodeWidth = ele.style('width');
                const width = parseInt(nodeWidth, 10);
                const textWidth = width - 24; // Account for padding
                
                // Get content
                const title = ele.data('title') || ele.id();
                const description = ele.data('description') || "";
                
                // Calculate lines for title and description based on available width
                const avgCharWidth = 7.5; // Approximate width for 13px font
                const charsPerLine = Math.floor(textWidth / avgCharWidth);
                
                // Calculate lines for title
                const titleWords = title.split(' ');
                let titleLines = 0;
                let currentLine = 0;
                
                titleWords.forEach(word => {
                  if (currentLine + word.length + 1 > charsPerLine) {
                    titleLines++;
                    currentLine = word.length;
                  } else {
                    currentLine += word.length + 1;
                  }
                });
                titleLines = Math.max(1, titleLines + (currentLine > 0 ? 1 : 0));
                
                // Calculate lines for description
                const descWords = description.split(' ');
                let descLines = 0;
                currentLine = 0;
                
                descWords.forEach(word => {
                  if (currentLine + word.length + 1 > charsPerLine) {
                    descLines++;
                    currentLine = word.length;
                  } else {
                    currentLine += word.length + 1;
                  }
                });
                descLines = Math.max(1, descLines + (currentLine > 0 ? 1 : 0));
                
                // Calculate total height needed
                const lineHeight = 18; // pixels per line
                const spacingBetweenTitleAndDesc = 20; // Space between title and description
                const totalPadding = 24; // 12px top + 12px bottom
                
                const nodeHeight = (titleLines * lineHeight) + 
                                  (descLines * lineHeight) + 
                                  spacingBetweenTitleAndDesc + 
                                  totalPadding;
                
                return Math.max(80, nodeHeight); // Ensure minimum height
              },
              'padding': 12, // Consistent padding
              'label': function(ele) {
                const title = ele.data('title') || ele.id();
                const description = ele.data('description') || "";
                return title + '\n\n' + description;
              },
              'line-height': 1.4 // Improve readability for multi-line text
            }
          },
          // Root node style
          {
            selector: `node[id = "${safeRootId}"]`,
            style: {
              'border-color': '#2563EB',
              'border-width': 2,
              'background-color': '#2563EB',
              'color': '#FFFFFF',
              'font-size': '13px',
              'font-weight': 'bold',
              'z-index': 10
            }
          },
          // Edge styles
          {
            selector: 'edge',
            style: {
              'width': 2,
              'line-color': 'data(color)',
              'target-arrow-color': 'data(color)',
              'target-arrow-shape': 'triangle',
              'curve-style': 'unbundled-bezier',
              'control-point-distances': [100, 100],
              'control-point-weights': [0.3, 0.7],
              'label': 'data(label)',
              'font-size': '11px',
              'text-background-color': 'white',
              'text-background-opacity': 0.9,
              'text-background-padding': '3px',
              'text-background-shape': 'rectangle',
              'font-family': 'Arial',
              'text-wrap': 'wrap',
              'text-max-width': '200px',
              'text-justification': 'center',
              'text-rotation': 'autorotate',
              'text-margin-y': '-10px',
              'text-events': 'yes'
            }
          },
          // Special style for edges from/to root
          {
            selector: `edge[source = "${safeRootId}"], edge[target = "${safeRootId}"]`,
            style: {
              'width': 2.5,
              'line-style': 'solid',
              'curve-style': 'straight',
              'control-point-distances': [0, 0],
              'line-color': 'data(color)'
            }
          }
        ],
        layout: {
          name: 'preset' // Start with preset to position root node
        }
      });
      
      // Calculate the center of the viewport
      const centerX = cy.width() / 2;
      const centerY = cy.height() / 2;
      
      // Position the root node higher in the viewport to reduce whitespace at the top
      // Use 1/3 of the height instead of 1/2 to move it up
      const rootNodeY = Math.min(centerY * 0.6, centerY - 100);
      
      // First position the root node at the horizontal center but higher vertically
      const rootNode = cy.$(`node[id = "${safeRootId}"]`);
      if (rootNode.length > 0) {
        rootNode.position({
          x: centerX,
          y: rootNodeY
        });
        
        // Lock the root node position to prevent it from moving during layout
        rootNode.lock();
      }
      
      // Get all non-root nodes for circular distribution
      const nonRootNodes = cy.$(`node[id != "${safeRootId}"]`);
      
      // Calculate optimal spacing based on node count and content
      const nodeCount = nonRootNodes.length;
      const minViewportDim = Math.min(cy.width(), cy.height());
      
      // Estimate node sizes based on content
      const nodeSizes = new Map();
      nonRootNodes.forEach(node => {
        const description = node.data('description') || "";
        let nodeHeight = 40; // Base height for title-only nodes
        
        if (description) {
          // Estimate height based on description length
          const charsPerLine = 25;
          const lineHeight = 18; // pixels per line of text
          const descriptionLines = Math.ceil(description.length / charsPerLine);
          nodeHeight = 40 + (descriptionLines * lineHeight) + 15;
          nodeHeight = Math.max(80, nodeHeight);
        }
        
        // Store the estimated size
        nodeSizes.set(node.id(), {
          width: 180, // Fixed width
          height: nodeHeight
        });
      });
      
      // Distribute nodes across multiple concentric circles
      // Group nodes by category for better organization
      const nodesByCategory = {};
      const edgeCategories = new Set();
  
      // Collect edge categories and organize nodes by their connection categories
      nonRootNodes.forEach(node => {
        const connectedEdges = node.connectedEdges();
        
        if (connectedEdges && connectedEdges.length > 0) {
          connectedEdges.forEach(edge => {
            if (edge && edge.data) {
              const category = edge.data('category');
              if (category) {
                edgeCategories.add(category);
                
                if (!nodesByCategory[category]) {
                  nodesByCategory[category] = [];
                }
                
                // Only add the node once per category
                if (!nodesByCategory[category].includes(node)) {
                  nodesByCategory[category].push(node);
                }
              }
            }
          });
        }
        
        // If node has no connections, add to "OTHER" category
        if (!connectedEdges || connectedEdges.length === 0) {
          if (!nodesByCategory["OTHER"]) {
            nodesByCategory["OTHER"] = [];
          }
          nodesByCategory["OTHER"].push(node);
        }
      });
  
      // Convert categories to array and sort
      const categories = Array.from(edgeCategories);
      categories.sort();
      
      // Calculate spacing multiplier based on node count and average node size
      let totalHeight = 0;
      nodeSizes.forEach(size => {
        totalHeight += size.height;
      });
      const avgNodeHeight = totalHeight / nodeSizes.size || 60;
      
      // Check if we're on a mobile device
      const isMobile = window.innerWidth < 768;
      
      // Adjust spacing based on node count and average size
      let spacingMultiplier = isMobile ? 1.3 : 1.4; // Adjusted from 1.5 to be more responsive
      if (nodeCount > 30) {
        spacingMultiplier = isMobile ? 2.2 : 2.3; // Adjusted from 2.5 to be more responsive
      } else if (nodeCount > 20) {
        spacingMultiplier = isMobile ? 1.8 : 1.9; // Adjusted from 2.0 to be more responsive
      } else if (nodeCount > 10) {
        spacingMultiplier = isMobile ? 1.6 : 1.7; // Adjusted from 1.8 to be more responsive
      }
      
      // Further adjust based on average node height
      if (avgNodeHeight > 100) {
        spacingMultiplier *= isMobile ? 1.25 : 1.3; // Adjusted for mobile
      } else if (avgNodeHeight > 80) {
        spacingMultiplier *= isMobile ? 1.15 : 1.2; // Adjusted for mobile
      }
      
      // Adjust based on viewport size
      const viewportArea = cy.width() * cy.height();
      if (viewportArea < 250000) { // Small viewport (e.g., mobile)
        spacingMultiplier *= 0.85; // Reduce spacing on small screens
      } else if (viewportArea > 800000) { // Large viewport
        spacingMultiplier *= 1.1; // Increase spacing on large screens
      }
      
      // Calculate the number of nodes per circle to avoid overcrowding
      const nodesPerCircle = Math.min(
        Math.max(isMobile ? 4 : 5, Math.floor(12 / spacingMultiplier)), 
        isMobile ? 7 : 8
      );
      
      // Position nodes by category in sectors around the root
      let nodeIndex = 0;
      const nodePositions = new Map(); // Store positions to check for collisions
      
      // Improved function to check if a position would cause overlap
      function wouldOverlap(x, y, nodeId) {
        const nodeSize = nodeSizes.get(nodeId);
        if (!nodeSize) return false;
        
        const nodeWidth = nodeSize.width;
        const nodeHeight = nodeSize.height;
        
        // Increase padding based on screen size
        const isMobile = window.innerWidth < 768;
        const padding = isMobile ? 50 : 45; // Increased from 40 to 45/50 for even better spacing
        
        for (const [id, pos] of nodePositions.entries()) {
          if (id === nodeId) continue; // Skip self
          
          const otherSize = nodeSizes.get(id);
          if (!otherSize) continue;
          
          const dx = Math.abs(x - pos.x);
          const dy = Math.abs(y - pos.y);
          
          // Check if nodes would overlap with increased padding
          if (dx < (nodeWidth + otherSize.width) / 2 + padding && 
              dy < (nodeHeight + otherSize.height) / 2 + padding) {
            return true;
          }
        }
        return false;
      }
      
      // Improved function to find a non-overlapping position with spiral pattern
      function findNonOverlappingPosition(baseX, baseY, nodeId, attempts = 40) { // Increased from 30 to 40 attempts
        if (!wouldOverlap(baseX, baseY, nodeId)) {
          return { x: baseX, y: baseY };
        }
        
        // Check if we're on a mobile device
        const isMobile = window.innerWidth < 768;
        
        // Try spiral pattern for better distribution
        const spiralStep = isMobile ? 45 : 40; // Increased from 40 to 45 on mobile
        const angleStep = Math.PI / 16; // Decreased from PI/12 to PI/16 for more positions per circle
        let angle = 0;
        let radius = spiralStep;
        
        for (let i = 1; i <= attempts; i++) {
          // Calculate position in spiral pattern
          const newX = baseX + Math.cos(angle) * radius;
          const newY = baseY + Math.sin(angle) * radius;
          
          if (!wouldOverlap(newX, newY, nodeId)) {
            return { x: newX, y: newY };
          }
          
          // Increase angle and occasionally increase radius for spiral effect
          angle += angleStep;
          if (i % 16 === 0) { // After full circle (16 * PI/16 = PI)
            radius += spiralStep;
          }
        }
        
        // If all attempts fail, try a random position further away
        const randomAngle = Math.random() * 2 * Math.PI;
        const randomDistance = 150 + Math.random() * 150; // Between 150-300px away (increased from 100-200)
        return { 
          x: baseX + Math.cos(randomAngle) * randomDistance, 
          y: baseY + Math.sin(randomAngle) * randomDistance 
        };
      }
      
      // Apply force-directed adjustments to reduce overlaps
      function applyForceDirectedAdjustments(maxIterations = 15) { // Increased from 10 to 15 iterations
        const isMobile = window.innerWidth < 768;
        
        for (let iteration = 0; iteration < maxIterations; iteration++) {
          let overlapsFound = false;
          
          // Check each pair of nodes for overlaps
          const nodeIds = Array.from(nodePositions.keys());
          
          for (let i = 0; i < nodeIds.length; i++) {
            const nodeId1 = nodeIds[i];
            const pos1 = nodePositions.get(nodeId1);
            const size1 = nodeSizes.get(nodeId1);
            if (!size1) continue;
            
            for (let j = i + 1; j < nodeIds.length; j++) {
              const nodeId2 = nodeIds[j];
              const pos2 = nodePositions.get(nodeId2);
              const size2 = nodeSizes.get(nodeId2);
              if (!size2) continue;
              
              // Calculate distance and overlap
              const dx = pos2.x - pos1.x;
              const dy = pos2.y - pos1.y;
              const distance = Math.sqrt(dx * dx + dy * dy);
              
              // Increase minimum distance on mobile
              const padding = isMobile ? 50 : 45; // Increased from 40 to 45/50
              const minDistance = (size1.width + size2.width) / 2 + padding;
              
              // If overlapping, push nodes apart
              if (distance < minDistance) {
                overlapsFound = true;
                
                // Calculate repulsion force - use a stronger force
                const force = (minDistance - distance) / (isMobile ? 1.2 : 1.4); // Adjusted from 1.5 to 1.4/1.2 for stronger adjustment
                const forceX = force * dx / distance;
                const forceY = force * dy / distance;
                
                // Apply force to both nodes (move them apart)
                nodePositions.set(nodeId1, { 
                  x: pos1.x - forceX, 
                  y: pos1.y - forceY 
                });
                
                nodePositions.set(nodeId2, { 
                  x: pos2.x + forceX, 
                  y: pos2.y + forceY 
                });
              }
            }
          }
          
          if (!overlapsFound) break;
        }
        
        // Add an additional pass to ensure root node connections are well-spaced
        if (safeRootId) {
          const rootPos = nodePositions.get(safeRootId);
          if (rootPos) {
            // Get all nodes directly connected to root
            const rootConnections = [];
            for (const [nodeId, _] of nodePositions.entries()) {
              if (nodeId !== safeRootId) {
                // Check if this node has a direct edge to/from root
                const hasDirectConnection = globalAllEdges.some(e => 
                  (e.from === rootSubject && e.to === nodeId.replace(/_/g, ' ')) || 
                  (e.to === rootSubject && e.from === nodeId.replace(/_/g, ' '))
                );
                
                if (hasDirectConnection) {
                  rootConnections.push(nodeId);
                }
              }
            }
            
            // Apply additional spacing to root connections
            for (let i = 0; i < rootConnections.length; i++) {
              const nodeId1 = rootConnections[i];
              const pos1 = nodePositions.get(nodeId1);
              if (!pos1) continue;
              
              for (let j = i + 1; j < rootConnections.length; j++) {
                const nodeId2 = rootConnections[j];
                const pos2 = nodePositions.get(nodeId2);
                if (!pos2) continue;
                
                const size1 = nodeSizes.get(nodeId1);
                const size2 = nodeSizes.get(nodeId2);
                if (!size1 || !size2) continue;
                
                // Calculate distance between these two root connections
                const dx = pos2.x - pos1.x;
                const dy = pos2.y - pos1.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                // Use extra padding for root connections
                const extraPadding = isMobile ? 60 : 55;
                const minDistance = (size1.width + size2.width) / 2 + extraPadding;
                
                if (distance < minDistance) {
                  // Apply stronger force for root connections
                  const force = (minDistance - distance) / (isMobile ? 1.0 : 1.2);
                  const forceX = force * dx / distance;
                  const forceY = force * dy / distance;
                  
                  // Apply force to both nodes
                  nodePositions.set(nodeId1, { 
                    x: pos1.x - forceX, 
                    y: pos1.y - forceY 
                  });
                  
                  nodePositions.set(nodeId2, { 
                    x: pos2.x + forceX, 
                    y: pos2.y + forceY 
                  });
                }
              }
            }
          }
        }
      }
      
      categories.forEach((category, categoryIndex) => {
        const categoryNodes = nodesByCategory[category] || [];
        const categorySize = categoryNodes.length;
        
        if (categorySize === 0) return;
        
        // Calculate the sector angle for this category
        const sectorAngle = (2 * Math.PI) / categories.length;
        const sectorStart = categoryIndex * sectorAngle;
        
        // Position nodes in this category
        categoryNodes.forEach((node, i) => {
          // Calculate circle index based on position in category
          const circleIndex = Math.floor(i / nodesPerCircle);
          
          // Base radius increases with each circle - INCREASED BASE RADIUS
          const baseRadius = minViewportDim * 0.5; // Increased from 0.4 to 0.5 to spread nodes out more
          
          // Calculate radius with spacing multiplier
          const radius = (baseRadius * (1 + (circleIndex * 0.7))) * spacingMultiplier; // Increased multiplier from 0.6 to 0.7
          
          // Calculate angle within sector
          const nodesInThisCircle = Math.min(nodesPerCircle, categorySize - (circleIndex * nodesPerCircle));
          const nodeAngleInSector = (i % nodesPerCircle) / nodesInThisCircle;
          const angle = sectorStart + (nodeAngleInSector * sectorAngle);
          
          // Calculate base position
          const baseX = centerX + radius * Math.cos(angle);
          const baseY = centerY + radius * Math.sin(angle);
          
          // Find non-overlapping position
          const position = findNonOverlappingPosition(baseX, baseY, node.id());
          
          // Set position
          node.position(position);
          
          // Store position for collision detection
          nodePositions.set(node.id(), position);
          
          nodeIndex++;
        });
      });
  
      // Handle any remaining nodes not assigned to categories
      if (nodesByCategory["OTHER"] && nodesByCategory["OTHER"].length > 0) {
        const otherNodes = nodesByCategory["OTHER"];
        
        otherNodes.forEach((node, i) => {
          const circleIndex = Math.floor(i / nodesPerCircle);
          const baseRadius = minViewportDim * 0.5; // Increased from 0.4 to 0.5
          const radius = (baseRadius * (1 + (circleIndex * 0.7))) * spacingMultiplier; // Increased multiplier from 0.6 to 0.7
          
          // Distribute "OTHER" nodes evenly around the circle
          const angle = (2 * Math.PI * i) / Math.min(nodesPerCircle, otherNodes.length);
          
          // Calculate base position
          const baseX = centerX + radius * Math.cos(angle);
          const baseY = centerY + radius * Math.sin(angle);
          
          // Find non-overlapping position
          const position = findNonOverlappingPosition(baseX, baseY, node.id());
          
          // Set position
          node.position(position);
          
          // Store position for collision detection
          nodePositions.set(node.id(), position);
        });
      }
      
      // Apply force-directed adjustments to reduce any remaining overlaps
      applyForceDirectedAdjustments();
      
      // Apply final positions to nodes after force-directed adjustments
      for (const [nodeId, position] of nodePositions.entries()) {
        const node = cy.$(`#${nodeId}`);
        if (node.length > 0) {
          node.position(position);
        }
      }
      
      // After layout completes, ensure the root node is still positioned higher in the viewport
      setTimeout(() => {
        try {
          // Force root node to maintain its higher position
          if (rootNode.length > 0) {
            rootNode.unlock();
            rootNode.position({
              x: centerX,
              y: rootNodeY
            });
            rootNode.lock(); // Lock it again
          }
          
          // Calculate optimal zoom level based on graph dimensions
          function calculateOptimalZoom() {
            // Get the graph's bounding box
            const boundingBox = cy.elements().boundingBox();
            
            // Get viewport dimensions
            const viewportWidth = cy.width();
            const viewportHeight = cy.height();
            
            // Calculate the graph's aspect ratio
            const graphWidth = boundingBox.w;
            const graphHeight = boundingBox.h;
            
            // Calculate how much we need to scale to fit the graph in the viewport
            // with padding (75% of viewport)
            const widthRatio = (viewportWidth * 0.75) / graphWidth;
            const heightRatio = (viewportHeight * 0.75) / graphHeight;
            
            // Use the smaller ratio to ensure the graph fits in both dimensions
            let optimalZoom = Math.min(widthRatio, heightRatio);
            
            // Apply a more aggressive adjustment based on node count
            const nodeCount = cy.nodes().length;
            const edgeCount = cy.edges().length;
            
            // Check if we're on a mobile device
            const isMobile = window.innerWidth < 768;
            
            // Calculate edge-to-node ratio to detect densely connected graphs
            const edgeToNodeRatio = nodeCount > 0 ? edgeCount / nodeCount : 0;
            
            // Calculate a logarithmic scaling factor for smoother transitions
            // This creates a more gradual scaling as node count increases
            const logBase = 10;
            const logFactor = nodeCount > logBase ? 
                              (1 - (Math.log(nodeCount) / Math.log(logBase)) * 0.2) : 
                              1;
            
            // Apply additional scaling for graphs with high edge-to-node ratios
            let densityFactor = 1.0;
            if (edgeToNodeRatio > 3) {
                // Very dense graph
                densityFactor = 0.6;
            } else if (edgeToNodeRatio > 2) {
                // Moderately dense graph
                densityFactor = 0.7;
            } else if (edgeToNodeRatio > 1.5) {
                // Slightly dense graph
                densityFactor = 0.8;
            } else if (edgeToNodeRatio > 1) {
                // Slightly dense graph
                densityFactor = 0.9;
            }
            
            // For very large graphs or graphs with many connections, reduce zoom significantly
            if (nodeCount > 100 || edgeCount > 200) {
              // Very large graphs need much more aggressive scaling
              optimalZoom *= isMobile ? 0.25 : 0.3;
            } else if (nodeCount > 70 || edgeCount > 140) {
              optimalZoom *= isMobile ? 0.3 : 0.35;
            } else if (nodeCount > 50 || edgeCount > 100) {
              optimalZoom *= isMobile ? 0.35 : 0.4;
            } else if (nodeCount > 40 || edgeCount > 80) {
              optimalZoom *= isMobile ? 0.4 : 0.45;
            } else if (nodeCount > 30 || edgeCount > 60) {
              optimalZoom *= isMobile ? 0.45 : 0.5;
            } else if (nodeCount > 20 || edgeCount > 40) {
              optimalZoom *= isMobile ? 0.55 : 0.6;
            } else if (nodeCount > 10 || edgeCount > 20) {
              optimalZoom *= isMobile ? 0.65 : 0.75;
            } else {
              // For very small graphs, still ensure everything fits
              optimalZoom *= isMobile ? 0.8 : 0.9;
            }
            
            // Apply the logarithmic scaling factor for smoother transitions
            optimalZoom *= logFactor;
            
            // Apply the density factor for graphs with many edges
            optimalZoom *= densityFactor;
            
            // Ensure zoom is within reasonable bounds
            // Adjust minimum zoom level based on node count
            const minZoom = nodeCount > 50 ? (isMobile ? 0.15 : 0.2) :
                           nodeCount > 30 ? (isMobile ? 0.2 : 0.25) :
                           nodeCount > 10 ? (isMobile ? 0.25 : 0.3) :
                           (isMobile ? 0.3 : 0.35);
            
            optimalZoom = Math.max(minZoom, Math.min(optimalZoom, 1.2));
            
            console.log(`Calculated optimal zoom: ${optimalZoom} for ${nodeCount} nodes and ${edgeCount} edges (mobile: ${isMobile}), edge-to-node ratio: ${edgeToNodeRatio.toFixed(2)}`);
            
            return optimalZoom;
          }
          
          // Apply the calculated optimal zoom and ensure everything fits
          const optimalZoom = calculateOptimalZoom();
          
          // First fit all elements to the viewport with less padding
          cy.fit(cy.elements(), 30); // Reduced from 50px to 30px padding
          
          // Then apply our calculated zoom
          cy.zoom({
            level: optimalZoom,
            renderedPosition: { x: cy.width() / 2, y: cy.height() / 3 } // Position viewport higher
          });
          
          // Instead of centering, pan to position the graph higher in the viewport
          const extent = cy.extent();
          cy.pan({
            x: -extent.x1 + (cy.width() - extent.w) / 2,
            y: -extent.y1 + (cy.height() - extent.h) / 3 // Use 1/3 instead of 1/2 to move up
          });
          
          // Check if all elements are visible with the current zoom
          function ensureAllElementsVisible() {
            // Get the current viewport extents
            const extent = cy.extent();
            const viewportWidth = extent.w;
            const viewportHeight = extent.h;
            
            // Get the bounding box of all elements
            const boundingBox = cy.elements().boundingBox();
            const graphWidth = boundingBox.w;
            const graphHeight = boundingBox.h;
            
            // Check if graph dimensions exceed viewport dimensions
            const widthRatio = viewportWidth / graphWidth;
            const heightRatio = viewportHeight / graphHeight;
            
            // If either ratio is less than 1, not all elements are visible
            if (widthRatio < 1 || heightRatio < 1) {
              console.log(`Graph doesn't fit in viewport. Width ratio: ${widthRatio.toFixed(2)}, Height ratio: ${heightRatio.toFixed(2)}`);
              
              // Calculate a new zoom level with additional safety margin
              const currentZoom = cy.zoom();
              const adjustmentFactor = Math.min(widthRatio, heightRatio) * 0.9; // 10% safety margin
              const newZoom = currentZoom * adjustmentFactor;
              
              console.log(`Adjusting zoom from ${currentZoom.toFixed(2)} to ${newZoom.toFixed(2)} to ensure all elements fit`);
              
              // Apply the adjusted zoom
              cy.zoom({
                level: newZoom,
                renderedPosition: { x: cy.width() / 2, y: cy.height() / 2 }
              });
              
              // Center the graph again
              cy.center();
              
              return true; // Adjustment was made
            }
            
            return false; // No adjustment needed
          }
          
          // Apply the visibility check after a short delay to ensure rendering is complete
          setTimeout(() => {
            ensureAllElementsVisible();
          }, 100);
          
          // Note: Window resize handler moved to the end of the initialization
          
          // Show download button
          $('#downloadBtn').show();
          
          // Add event listeners for control buttons
          $('#zoom-in').off('click').on('click', function() {
            cy.zoom({
              level: cy.zoom() * 1.2,
              renderedPosition: { x: cy.width() / 2, y: cy.height() / 2 }
            });
          });
          
          $('#zoom-out').off('click').on('click', function() {
            cy.zoom({
              level: cy.zoom() * 0.8,
              renderedPosition: { x: cy.width() / 2, y: cy.height() / 2 }
            });
          });
          
          $('#reset-view').off('click').on('click', function() {
            cy.fit();
            cy.center();
          });
          
          // Add toggle for edge labels
          let edgeLabelsVisible = true;
          $('#toggle-labels').off('click').on('click', function() {
            edgeLabelsVisible = !edgeLabelsVisible;
            
            // Update edge styles
            cy.style()
              .selector('edge')
              .style({
                'label': function(ele) {
                  if (!edgeLabelsVisible) return '';
                  return nodeCount > 15 ? '' : ele.data('label');
                }
              })
              .selector(`edge[source = "${safeRootId}"], edge[target = "${safeRootId}"]`)
              .style({
                'label': function(ele) {
                  if (!edgeLabelsVisible) return '';
                  return ele.data('label');
                }
              })
              .update();
            
            // Update button appearance
            $(this).css('background-color', edgeLabelsVisible ? 'white' : '#f0f0f0');
          });
          
          // Add toggle for showing only root connections
          let onlyRootConnections = false;
          $('#toggle-secondary').off('click').on('click', function() {
            onlyRootConnections = !onlyRootConnections;
            
            if (onlyRootConnections) {
              // Hide non-root edges
              cy.edges().forEach(edge => {
                const isRootEdge = edge.data('source') === safeRootId || edge.data('target') === safeRootId;
                edge.style('opacity', isRootEdge ? 1 : 0.1);
              });
            } else {
              // Restore all edges
              cy.edges().forEach(edge => {
                edge.style('opacity', 1);
              });
            }
            
            // Update button appearance
            $(this).css('background-color', onlyRootConnections ? '#e6f7ff' : 'white');
          });
          
          // Apply improved node styling to ensure text fits
          fixNodeStyling();
          
          // Enable touch gestures for mobile
          cy.userZoomingEnabled(true);
          cy.userPanningEnabled(true);
          cy.boxSelectionEnabled(false);
          
          // Track the currently selected node for touch devices
          let selectedNode = null;
          // Track long press timer
          let longPressTimer = null;
          // Long press duration in milliseconds
          const longPressDuration = 500;
          
          // Function to highlight a node and its connections
          function highlightNode(node) {
            if (!node) return;
            
            // Safely get connected edges
            let connectedEdges = [];
            try {
              const tempEdges = node.connectedEdges();
              if (tempEdges && typeof tempEdges.forEach === 'function') {
                connectedEdges = tempEdges;
              }
            } catch (err) {
              console.warn('Error getting connected edges:', err);
            }
            
            // Safely get connected nodes
            let connectedNodes = [];
            try {
              if (connectedEdges && typeof connectedEdges.connectedNodes === 'function') {
                const tempNodes = connectedEdges.connectedNodes();
                if (tempNodes && typeof tempNodes.forEach === 'function') {
                  connectedNodes = tempNodes;
                }
              }
            } catch (err) {
              console.warn('Error getting connected nodes:', err);
            }
            
            // Safely get difference
            let difference = [];
            try {
              if (connectedNodes && typeof connectedNodes.difference === 'function') {
                const tempDiff = connectedNodes.difference(node);
                if (tempDiff && typeof tempDiff.forEach === 'function') {
                  difference = tempDiff;
                }
              }
            } catch (err) {
              console.warn('Error calculating node difference:', err);
            }
            
            // Dim all elements safely
            try {
              let elementsToFade = [];
              const allElements = cy.elements();
              if (allElements && typeof allElements.difference === 'function') {
                const tempElements = allElements.difference(node);
                if (tempElements && typeof tempElements.forEach === 'function') {
                  elementsToFade = tempElements;
                }
              }
              
              // Apply opacity to each element individually
              if (elementsToFade.length > 0) {
                elementsToFade.forEach(ele => {
                  if (ele && typeof ele.style === 'function') {
                    ele.style('opacity', 0.2);
                  }
                });
              }
            } catch (err) {
              console.warn('Error dimming elements:', err);
            }
            
            // Highlight connected elements safely
            try {
              if (connectedEdges.length > 0) {
                connectedEdges.forEach(edge => {
                  if (edge && typeof edge.style === 'function') {
                    edge.style('opacity', 1);
                  }
                });
              }
            } catch (err) {
              console.warn('Error highlighting connected edges:', err);
            }
            
            try {
              if (difference.length > 0) {
                difference.forEach(connNode => {
                  if (connNode && typeof connNode.style === 'function') {
                    connNode.style('opacity', 1);
                  }
                });
              }
            } catch (err) {
              console.warn('Error highlighting connected nodes:', err);
            }
            
            // Make the selected node stand out
            try {
              if (typeof node.style === 'function') {
                node.style('border-width', 3);
                node.style('border-color', '#FFA500');
              }
            } catch (err) {
              console.warn('Error styling selected node:', err);
            }
            
            // Show edge labels for connected edges if there are many nodes
            try {
              if (nodeCount > 15 && connectedEdges.length > 0) {
                connectedEdges.forEach(edge => {
                  if (!edge || typeof edge.data !== 'function' || typeof edge.style !== 'function') return;
                  try {
                    const label = edge.data('label');
                    edge.style('label', label || '');
                  } catch (labelErr) {
                    console.warn('Error setting edge label:', labelErr);
                  }
                });
              }
            } catch (err) {
              console.warn('Error showing edge labels:', err);
            }
          }
          
          // Function to restore all elements to their original state
          function resetHighlighting() {
            try {
              // Restore all elements to original state - with safer collection handling
              try {
                let elements = [];
                const tempElements = cy.elements();
                if (tempElements && typeof tempElements.forEach === 'function') {
                  elements = tempElements;
                }
                
                if (elements.length > 0) {
                  elements.forEach(ele => {
                    if (ele && typeof ele.style === 'function') {
                      ele.style('opacity', 1);
                    }
                  });
                }
              } catch (err) {
                console.warn('Error restoring element opacity:', err);
              }
              
              // Restore node border - with safer collection handling
              try {
                let nodes = [];
                const tempNodes = cy.nodes();
                if (tempNodes && typeof tempNodes.forEach === 'function') {
                  nodes = tempNodes;
                }
                
                if (nodes.length > 0) {
                  nodes.forEach(node => {
                    if (!node || typeof node.data !== 'function' || typeof node.style !== 'function') return;
                    try {
                      const isRoot = node.id() === safeRootId;
                      node.style('border-width', isRoot ? 3 : 1);
                      node.style('border-color', isRoot ? '#2563EB' : '#94A3B8');
                    } catch (nodeErr) {
                      console.warn('Error styling node border:', nodeErr);
                    }
                  });
                }
              } catch (err) {
                console.warn('Error restoring node borders:', err);
              }
              
              // Hide edge labels again if there are many nodes - with safer collection handling
              try {
                if (nodeCount > 15) {
                  let edges = [];
                  const tempEdges = cy.edges();
                  if (tempEdges && typeof tempEdges.forEach === 'function') {
                    edges = tempEdges;
                  }
                  
                  if (edges.length > 0) {
                    edges.forEach(edge => {
                      if (!edge || typeof edge.data !== 'function' || typeof edge.style !== 'function') return;
                      try {
                        if (!edgeLabelsVisible) {
                          edge.style('label', '');
                        } else {
                          const isRootEdge = edge.data('source') === safeRootId || edge.data('target') === safeRootId;
                          edge.style('label', isRootEdge ? edge.data('label') || '' : '');
                        }
                      } catch (edgeErr) {
                        console.warn('Error styling edge label:', edgeErr);
                      }
                    });
                  }
                }
              } catch (err) {
                console.warn('Error hiding edge labels:', err);
              }
              
              // Reset the selected node
              selectedNode = null;
              
              // Clear any pending long press timer
              if (longPressTimer) {
                clearTimeout(longPressTimer);
                longPressTimer = null;
              }
            } catch (e) {
              console.warn('Error in reset highlighting:', e);
            }
          }
          
          // Add hover interactions for nodes (desktop)
          cy.on('mouseover', 'node', function(e) {
            try {
              const node = e.target;
              highlightNode(node);
            } catch (err) {
              console.warn('Error in mouseover handler:', err);
            }
          });
          
          cy.on('mouseout', 'node', function() {
            resetHighlighting();
          });
          
          // Add touch interactions for nodes (mobile/touch devices)
          cy.on('tap', 'node', function(e) {
            try {
              const node = e.target;
              
              // If this node is already selected, do nothing (let the background tap handle it)
              if (selectedNode && selectedNode.id() === node.id()) {
                return;
              }
              
              // Reset any previous selection
              resetHighlighting();
              
              // Highlight the tapped node
              highlightNode(node);
              
              // Store the selected node
              selectedNode = node;
              
              // Prevent event propagation to avoid triggering the background tap
              e.originalEvent.stopPropagation();
            } catch (err) {
              console.warn('Error in node tap handler:', err);
            }
          });
          
          // Add tap handler for background to reset highlighting
          cy.on('tap', function(e) {
            // Only handle taps directly on the background (not on nodes)
            if (e.target === cy) {
              resetHighlighting();
            }
          });
          
          // Add touch start handler for long press detection
          cy.on('touchstart', 'node', function(e) {
            try {
              console.log('touchstart on node triggered');
              const node = e.target;
              
              // Immediately highlight the node on touch start
              resetHighlighting();
              highlightNode(node);
              selectedNode = node;
              
              // Clear any existing timer
              if (longPressTimer) {
                clearTimeout(longPressTimer);
              }
              
              // Set a timer for long press
              longPressTimer = setTimeout(function() {
                console.log('long press detected');
                // Reset any previous selection
                resetHighlighting();
                
                // Highlight the long-pressed node
                highlightNode(node);
                
                // Store the selected node
                selectedNode = node;
                
                // Clear the timer
                longPressTimer = null;
              }, longPressDuration);
              
              // Prevent default to avoid issues with scrolling
              e.originalEvent.preventDefault();
            } catch (err) {
              console.warn('Error in touchstart handler:', err);
            }
          });
          
          // Cancel long press on touch move and check for nodes under touch
          cy.on('touchmove', function(e) {
            console.log('touchmove triggered');
            
            if (longPressTimer) {
              clearTimeout(longPressTimer);
              longPressTimer = null;
            }
            
            // Check if we're dragging over a node
            try {
              // Get the position of the touch event
              if (!e.originalEvent || !e.originalEvent.touches || e.originalEvent.touches.length === 0) {
                console.log('No touch data available');
                return;
              }
              
              // Get the touch position relative to the canvas
              const touch = e.originalEvent.touches[0];
              const container = cy.container();
              const rect = container.getBoundingClientRect();
              const touchPosition = {
                x: touch.clientX - rect.left,
                y: touch.clientY - rect.top
              };
              
              console.log(`Touch position: x=${touchPosition.x}, y=${touchPosition.y}`);
              
              // Convert touch position to rendered position
              const renderedPosition = {
                x: touchPosition.x,
                y: touchPosition.y
              };
              
              // Try to find the node at this position using multiple methods
              let nodeUnderTouch = null;
              let nodeDistance = Infinity; // Track distance to closest node
              const MAX_TOUCH_DISTANCE = 50; // Maximum distance in pixels to consider a node as "touched"
              
              // Method 1: Use findNearestElement with distance check
              try {
                const nearestElement = cy.renderer().findNearestElement(renderedPosition.x, renderedPosition.y, true);
                
                if (nearestElement && nearestElement.isNode && nearestElement.isNode()) {
                  // Calculate distance to the nearest node
                  const nodePos = nearestElement.renderedPosition();
                  const dx = nodePos.x - renderedPosition.x;
                  const dy = nodePos.y - renderedPosition.y;
                  const distance = Math.sqrt(dx*dx + dy*dy);
                  
                  console.log(`Method 1: Distance to nearest node (${nearestElement.id()}): ${distance.toFixed(2)}px`);
                  
                  // Only consider the node if it's within the threshold distance
                  if (distance <= MAX_TOUCH_DISTANCE) {
                    nodeUnderTouch = nearestElement;
                    nodeDistance = distance;
                    console.log('Method 1 (findNearestElement) result:', nodeUnderTouch.id(), 'distance:', distance.toFixed(2));
                  } else {
                    console.log('Method 1: Node too far away (', distance.toFixed(2), '>', MAX_TOUCH_DISTANCE, ')');
                  }
                }
              } catch (err) {
                console.warn('Error using findNearestElement:', err);
              }
              
              // Method 2: If Method 1 fails, try using document.elementFromPoint
              if (!nodeUnderTouch) {
                try {
                  const element = document.elementFromPoint(touch.clientX, touch.clientY);
                  if (element && element.id) {
                    // Try to find a node with this ID or a node containing this element
                    const nodeId = element.id.replace('cy-', '');
                    const potentialNode = cy.$(`#${nodeId}`);
                    
                    if (potentialNode && potentialNode.isNode && potentialNode.isNode()) {
                      // Calculate distance to this node
                      const nodePos = potentialNode.renderedPosition();
                      const dx = nodePos.x - renderedPosition.x;
                      const dy = nodePos.y - renderedPosition.y;
                      const distance = Math.sqrt(dx*dx + dy*dy);
                      
                      console.log(`Method 2: Distance to element node (${potentialNode.id()}): ${distance.toFixed(2)}px`);
                      
                      // Only consider the node if it's within the threshold distance
                      if (distance <= MAX_TOUCH_DISTANCE) {
                        nodeUnderTouch = potentialNode;
                        nodeDistance = distance;
                        console.log('Method 2 (elementFromPoint) result:', nodeUnderTouch.id(), 'distance:', distance.toFixed(2));
                      } else {
                        console.log('Method 2: Node too far away (', distance.toFixed(2), '>', MAX_TOUCH_DISTANCE, ')');
                      }
                    }
                  }
                } catch (err) {
                  console.warn('Error using elementFromPoint:', err);
                }
              }
              
              // Method 3: If Methods 1 and 2 fail, check all nodes to see if the touch point is within their bounding box
              if (!nodeUnderTouch) {
                try {
                  cy.nodes().forEach(node => {
                    // Calculate distance to this node
                    const nodePos = node.renderedPosition();
                    const dx = nodePos.x - renderedPosition.x;
                    const dy = nodePos.y - renderedPosition.y;
                    const distance = Math.sqrt(dx*dx + dy*dy);
                    
                    // Check if this node is closer than our current best match and within threshold
                    if (distance <= MAX_TOUCH_DISTANCE && distance < nodeDistance) {
                      // Additional check: is the touch point within the node's bounding box?
                      const bbox = node.renderedBoundingBox();
                      const inBoundingBox = (
                        renderedPosition.x >= bbox.x1 && 
                        renderedPosition.x <= bbox.x2 &&
                        renderedPosition.y >= bbox.y1 && 
                        renderedPosition.y <= bbox.y2
                      );
                      
                      if (inBoundingBox) {
                        nodeUnderTouch = node;
                        nodeDistance = distance;
                        console.log('Method 3 (bounding box check) found node:', node.id(), 'distance:', distance.toFixed(2));
                        return false; // Break the forEach loop
                      }
                    }
                  });
                } catch (err) {
                  console.warn('Error checking node bounding boxes:', err);
                }
              }
              
              if (nodeUnderTouch) {
                console.log(`Node found under touch: ${nodeUnderTouch.id()} at distance ${nodeDistance.toFixed(2)}px`);
                
                if (nodeUnderTouch.isNode && nodeUnderTouch.isNode()) {
                  console.log(`Node under touch is a valid node`);
                  
                  // If we found a node and it's different from the currently selected node
                  if (!selectedNode || selectedNode.id() !== nodeUnderTouch.id()) {
                    console.log(`Highlighting new node: ${nodeUnderTouch.id()}`);
                    
                    // Store the current selected node to preserve it during transition
                    const previousNode = selectedNode;
                    
                    // Update selected node before resetting highlighting
                    selectedNode = nodeUnderTouch;
                    
                    // If we already have a selected node, we're in a drag operation
                    // In this case, we want to highlight the new node without the fade effect
                    if (previousNode) {
                      // Apply highlighting directly to the new node without resetting
                      // This prevents the fade-out effect during dragging
                      try {
                        // Make all nodes except the selected one semi-transparent
                        cy.nodes().forEach(node => {
                          if (node.id() !== nodeUnderTouch.id()) {
                            node.style('opacity', 0.2);
                          } else {
                            // Make the selected node stand out
                            node.style('opacity', 1);
                            node.style('border-width', 3);
                            node.style('border-color', '#FFA500');
                          }
                        });
                        
                        // Make connected edges and nodes visible
                        const connectedEdges = nodeUnderTouch.connectedEdges();
                        connectedEdges.style('opacity', 1);
                        
                        // Make connected nodes visible
                        const connectedNodes = connectedEdges.connectedNodes();
                        connectedNodes.style('opacity', 1);
                        
                        // Show edge labels for connected edges if there are many nodes
                        if (cy.nodes().length > 15) {
                          connectedEdges.forEach(edge => {
                            const label = edge.data('label');
                            edge.style('label', label || '');
                          });
                        }
                      } catch (err) {
                        console.warn('Error applying direct highlighting:', err);
                        
                        // Fallback to standard highlighting if direct method fails
                        resetHighlighting();
                        highlightNode(nodeUnderTouch);
                      }
                    } else {
                      // If no previous node, use standard highlighting
                      resetHighlighting();
                      highlightNode(nodeUnderTouch);
                    }
                  }
                } else {
                  console.log('Element under touch is not a node');
                }
              } else {
                console.log('No element found under touch - too far from any node');
                // Don't reset highlighting when no node is found during a drag
                // This keeps the current node highlighted while dragging in empty space
              }
              
              // Prevent default to avoid scrolling
              e.originalEvent.preventDefault();
            } catch (err) {
              console.warn('Error in touchmove handler:', err);
            }
          });
          
          // Handle touch end
          cy.on('touchend', function(e) {
            console.log('touchend triggered');
            
            if (longPressTimer) {
              clearTimeout(longPressTimer);
              longPressTimer = null;
            }
            
            // Keep the current highlighting when touch ends
            // This allows the user to see what they've selected
          });
          
          // Improved window resize handler to fully recalculate the graph
          $(window).off('resize.cytoscape').on('resize.cytoscape', function() {
            // Debounce the resize event
            clearTimeout(window.cytoscapeResizeTimer);
            window.cytoscapeResizeTimer = setTimeout(function() {
              if (cy) {
                console.log("Window resized, recalculating graph layout...");
                
                // Get the current root subject
                const rootSubject = $('#graphTitle').text().trim();
                
                // Store current zoom and pan for smoother transition
                const currentZoom = cy.zoom();
                const currentPan = cy.pan();
                
                // Re-render the graph with the current active categories
                let activeEdges = globalAllEdges.filter(e => globalActiveCategories.has(e.category));
                
                // Check if we need to completely rebuild the graph
                const viewportWidth = cy.width();
                const viewportHeight = cy.height();
                const viewportArea = viewportWidth * viewportHeight;
                const significantResize = Math.abs(viewportArea - window.lastViewportArea) / window.lastViewportArea > 0.2;
                
                if (significantResize || !window.lastViewportArea) {
                  console.log("Significant resize detected, rebuilding graph layout");
                  // Store new viewport area
                  window.lastViewportArea = viewportArea;
                  
                  // Completely rebuild the graph
                  reRenderGraph(rootSubject);
                } else {
                  // Just recalculate optimal zoom
                  const newOptimalZoom = calculateOptimalZoom();
                  
                  // Apply new zoom with animation
                  cy.animate({
                    zoom: newOptimalZoom,
                    center: {
                      eles: cy.elements()
                    }
                  }, {
                    duration: 300,
                    complete: function() {
                      // After animation completes, check if all elements are visible
                      setTimeout(() => {
                        ensureAllElementsVisible();
                      }, 50);
                    }
                  });
                }
              }
            }, 250); // Wait 250ms after resize ends
          });
          
          // Store initial viewport area
          window.lastViewportArea = cy.width() * cy.height();
        } catch (err) {
          console.error("Error in layout processing:", err);
        }
      }, 100);
      
    } catch (err) {
      console.error("Error initializing Cytoscape:", err);
      $('#graph-container').html(
        `<div class="p-2 text-center text-sm text-red-500">Error rendering graph: ${err.message}</div>`
      );
    }
  }, 50); // Short delay to ensure DOM is ready

  // At the end of renderCytoscape function, after all the event handlers are set up
  setTimeout(() => {
    // Trigger a resize event to ensure proper centering
    $(window).trigger('resize.cytoscape');
  }, 300); // Give enough time for initial render to complete
}

// Re-render the graph with filtered edges
function reRenderGraph(rootSubject) {
  // Update the global safeRootId
  safeRootId = rootSubject.replace(/[^a-zA-Z0-9]/g, '_');
  
  let activeEdges = globalAllEdges.filter(e => globalActiveCategories.has(e.category));
  let elements = buildCytoscapeElements(rootSubject, globalNodesMap, activeEdges);
  renderCytoscape(rootSubject, elements);
}

/***************************************
* LEGEND & CATEGORY TOGGLING
***************************************/
function renderLegend(categories) {
  let html = '';
  categories.sort(); // optional: sort them alphabetically
  for (let c of categories) {
    let color = categoryColors[c] || categoryColors["UNKNOWN"];
    html += `<div class="legend-item" style="background-color: ${color};" data-cat="${c}">${c}</div>`;
  }
  $('#legend').html(html);

  // Attach click handler
  $('#legend .legend-item').on('click', function() {
    let cat = $(this).data('cat');
    toggleCategory(cat);
    $(this).toggleClass('disabled', !globalActiveCategories.has(cat));
  });
}

// Toggle a category in/out of the active set
function toggleCategory(cat) {
  if (globalActiveCategories.has(cat)) {
    globalActiveCategories.delete(cat);
  } else {
    globalActiveCategories.add(cat);
  }
  // re-render
  let rootName = $('#graphTitle').text().trim();
  reRenderGraph(rootName);
}


/***************************************
* DOWNLOAD PNG
***************************************/
$('#downloadBtn').on('click', function() {
  if (!window.cy) {
    alert('No graph to download');
    return;
  }
  
  try {
    // Show a loading indicator
    const $loadingIndicator = $('#loading-indicator');
    $loadingIndicator.show();
    
    // Use setTimeout to allow the UI to update before the potentially heavy PNG generation
    setTimeout(() => {
      try {
        // Create a PNG image with the current styling
        const png64 = cy.png({
          output: 'blob',
          scale: 2, // Higher resolution
          bg: 'white',
          full: true,
          maxWidth: 8000, // Set reasonable max dimensions
          maxHeight: 8000
        });
        
        // Create download link
        const url = URL.createObjectURL(png64);
        const link = document.createElement('a');
        link.href = url;
        link.download = 'relation_graph.png';
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        
        // Clean up the object URL after a short delay to ensure the download starts
        setTimeout(() => {
          URL.revokeObjectURL(url);
          $loadingIndicator.hide();
        }, 100);
      } catch (err) {
        console.error("Error generating PNG:", err);
        alert("Could not generate PNG. Error: " + err.message);
        $loadingIndicator.hide();
      }
    }, 100); // Small delay to allow UI to update
  } catch (err) {
    console.error("Error in PNG download process:", err);
    alert("Could not generate PNG. Please try again.");
  }
});


/***************************************
* HELPER
***************************************/
function escapeHtml(str) {
  if (!str) return '';
  return str
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;');
}

// Replace the entire fixNodeStyling function with this improved version
function fixNodeStyling() {
  console.log("fixNodeStyling called");
  
  // Safety check - if safeRootId is not defined, don't proceed
  if (!safeRootId) {
    console.warn("fixNodeStyling called but safeRootId is not defined");
    return;
  }
  
  // Get all nodes
  const allNodes = cy.nodes();
  
  // Update node styling to use Cytoscape's built-in labels
  allNodes.forEach(node => {
    try {
      const title = node.data('title') || node.id();
      const description = node.data('description') || "";
      const isRoot = node.id() === safeRootId;
      
      // Format the label with the title and description
      let labelText = title;
      if (description) {
        labelText = title + '\n\n' + description;
      }
      
      // More accurate calculation of text dimensions
      // Calculate width based on longest line
      const titleWords = title.split(' ');
      const descWords = description ? description.split(' ') : [];
      const allWords = [...titleWords, ...descWords];
      
      // Estimate average character width (in pixels) for the font
      const avgCharWidth = 7.5; // Approximate width for 13px font
      
      // Find the longest word to ensure it fits
      let longestWordLength = 0;
      allWords.forEach(word => {
        longestWordLength = Math.max(longestWordLength, word.length);
      });
      
      // Calculate minimum width needed for the longest word
      const minWidthNeeded = longestWordLength * avgCharWidth + 24; // Add padding
      
      // Set node width, ensuring it's at least wide enough for the longest word
      const nodeWidth = Math.max(180, minWidthNeeded);
      
      // Calculate height more accurately
      const maxTextWidth = nodeWidth - 24; // Account for padding (12px on each side)
      const charsPerLine = Math.floor(maxTextWidth / avgCharWidth);
      
      // Calculate lines for title
      let titleLines = 0;
      let currentLine = 0;
      titleWords.forEach(word => {
        if (currentLine + word.length + 1 > charsPerLine) {
          titleLines++;
          currentLine = word.length;
        } else {
          currentLine += word.length + 1;
        }
      });
      titleLines = Math.max(1, titleLines + (currentLine > 0 ? 1 : 0));
      
      // Calculate lines for description
      let descLines = 0;
      currentLine = 0;
      if (description) {
        descWords.forEach(word => {
          if (currentLine + word.length + 1 > charsPerLine) {
            descLines++;
            currentLine = word.length;
          } else {
            currentLine += word.length + 1;
          }
        });
        descLines = Math.max(1, descLines + (currentLine > 0 ? 1 : 0));
      }
      
      // Calculate total height needed
      const lineHeight = 18; // pixels per line
      const spacingBetweenTitleAndDesc = description ? 20 : 0; // Space between title and description
      const totalPadding = 24; // 12px top + 12px bottom
      
      const nodeHeight = (titleLines * lineHeight) + 
                         (descLines * lineHeight) + 
                         spacingBetweenTitleAndDesc + 
                         totalPadding;
      
      // Common styling for all nodes
      const commonStyles = {
        'label': labelText,
        'text-wrap': 'wrap',
        'text-max-width': nodeWidth - 24, // Account for padding
        'font-size': 13,
        'color': isRoot ? '#FFFFFF' : '#000000',
        'text-outline-width': 0,
        'text-outline-opacity': 0,
        'width': nodeWidth,
        'height': nodeHeight,
        'shape': 'round-rectangle',
        'background-color': isRoot ? '#2563EB' : '#F3F4F6',
        'border-color': isRoot ? '#2563EB' : '#94A3B8',
        'border-width': isRoot ? 2 : 1,
        'font-weight': isRoot ? 'bold' : 'normal',
        'padding': 12, // Consistent padding on all sides
        'text-valign': 'center',
        'text-halign': 'center',
        'text-margin-y': 0,
        'line-height': 1.4
      };
      
      // Apply styling to the node
      node.style(commonStyles);
    } catch (err) {
      console.error(`Error styling node ${node.id()}:`, err);
    }
  });
  
  // Update the stylesheet
  cy.style().update();
}
</script>