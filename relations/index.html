---
layout: default
title: People Relations (BETA)
---

<!-- jQuery for convenience -->
<script src="jquery.min.js"></script>

<!-- D3.js -->
<script src="https://d3js.org/d3.v7.min.js"></script>

<!-- svg-pan-zoom for panning/zooming the resulting SVG -->
<script src="svg-pan-zoom.min.js"></script>

<!-- JSZip for reading zipped CSVs -->
<script src="jszip.min.js"></script>

<!-- Papa Parse for CSV parsing -->
<script src="papaparse.min.js"></script>

<script src="murmurHash3.js"></script>

<style>

  .shidden { display: none; }
  .toggle-btn {
    background: none;
    border: none;
    color: #2563EB;
    cursor: pointer;
    padding: 0;
  }
  .loading-spinner {
    vertical-align: middle;
  }
  #graph-container {
    width: 100%;
    height: 80vh;      /* or calc(100vh - someOffset) */
    position: relative;
    overflow: hidden;  /* if you like; up to you */
    display: flex;     /* Add flexbox to center content */
    justify-content: center; /* Center horizontally */
    align-items: flex-start; /* Align to the top instead of center */
    padding-top: 20px; /* Add some padding at the top */
  }
  #legend {
    display: flex;
    align-items: flex-start;
    flex-wrap: wrap;
    gap: 8px;
    margin-bottom: 0.5rem;
  }
  
  /* D3 Graph Styles */
  .node rect {
    fill: #F3F4F6;
    stroke: #94A3B8;
    stroke-width: 1px;
    filter: drop-shadow(0px 2px 3px rgba(0, 0, 0, 0.1));
  }
  .node.root rect {
    stroke: #2563EB;
    stroke-width: 3px;
    fill: #EFF6FF;
  }
  .node text {
    pointer-events: none;
  }
  .link {
    fill: none;
    stroke-width: 2px;
    filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.05));
  }
  .label-bg {
    fill: #F3F4F6;
    stroke: white;
    stroke-width: 2px;
    filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.1));
  }
  .link-label {
    fill: #475569;
    font-size: 12px;
    text-anchor: middle;
    pointer-events: none;
  }
  .legend-item {
    padding: 4px 8px;
    border-radius: 4px;
    font-size: 12px;
    cursor: pointer;
    color: white;
    margin-right: 4px;
    margin-bottom: 4px;
    box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
    transition: transform 0.2s ease, box-shadow 0.2s ease;
  }
  .legend-item:hover {
    transform: translateY(-1px);
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
  }
  .legend-item.disabled {
    opacity: 0.5;
    position: relative;
  }
  .legend-item.disabled::after {
    content: "";
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background-color: rgba(255, 255, 255, 0.3);
    border-radius: 4px;
  }
  
  /* Hover effects - using !important to override any inline styles */
  .node rect:hover {
    stroke: #2563EB !important;
    stroke-width: 3px !important;
  }
  
  .link:hover {
    stroke: #2563EB !important;
    stroke-width: 4px !important;
  }
  
  /* Arrow styling */
  .arrow-path {
    fill: #94A3B8;
  }
  
  #arrow .arrow-path {
    fill: #94A3B8;
  }
  
  /* Label styling */
  .label-bg:hover {
    fill: #2563EB !important;
  }
  
  /* Make all text in a label group white when the background is hovered */
  .link-label-group:hover .link-label {
    fill: white !important;
  }
  
  /* Custom data attribute selectors for connected elements */
  .link[data-highlighted="true"] {
    stroke: #2563EB !important;
    stroke-width: 4px !important;
  }
  
  .node rect[data-highlighted="true"] {
    stroke: #2563EB !important;
    stroke-width: 3px !important;
  }
  
  .label-bg[data-highlighted="true"] {
    fill: #2563EB !important;
  }
  
  .link-label[data-highlighted="true"] {
    fill: white !important;
  }
  
  /* When hovering a node, highlight connected links */
  .node:hover ~ .links .link {
    stroke: #2563EB !important;
    stroke-width: 4px !important;
  }
  
  /* When hovering a node, highlight connected labels */
  .node:hover ~ .label-group .link-label-group .label-bg {
    fill: #2563EB !important;
  }
  
  .node:hover ~ .label-group .link-label-group .link-label {
    fill: white !important;
  }
</style>

<!-- 
=========================
======== SEARCH UI ======
=========================

This container is displayed in "Search Mode" (no ?subject= in the URL),
letting the user enter a name, see results, and click to load GraphViz mode.
-->

<div id="searchMode" class="mb-4 shidden">
<h1 class="mb-1">People &amp; relationships lookup</h1>
<p class="text-sm mb-3">
  Search for a name or phrase. We'll do an inclusive search (all tokens must appear).
  Each matching subject is displayed along with a quick description. Click on a name to load its relationship graph.
</p>

<div id="searchFormWrapper" class="mb-4">
  <form id="searchForm" class="flex flex-wrap gap-2 items-end">
    <div>
      <label for="searchBox" class="text-sm font-bold mb-1">Name/Keyword(s)</label><br/>
      <input type="text" id="searchBox" class="border border-gray-200 rounded p-2 w-full" placeholder="E.g. 'aaron' or '14th Dalai Lama'"/>
    </div>

    <button type="submit" id="searchButton" class="p-2 border border-gray-200 rounded font-bold text-sm">
      <span class="button-text">Search</span>
      <img src="../assets/images/loading-white.svg" class="loading-spinner" style="display:none;width:16px;height:16px" alt="Loading..."/>
    </button>

    <div class="relative -top-1">
      <input type="checkbox" id="prefixCheck"/>
      <label for="prefixCheck" class="text-sm">Use prefix matching</label>
    </div>

    <span id="statusMessage" class="text-sm"></span>
  </form>
</div>

<div id="resultsContainer" class="flex flex-col gap-2"></div>
<div id="resultsStatus" class="mt-2 text-sm"></div>
</div>

<!-- 
===============================
======== GRAPHVIZ UI =========
===============================

This container is displayed in "GraphViz Mode" (when ?subject= is in the URL, or after user clicks on a result).
It shows the generated graph and a legend, plus a button to go back to the search mode.
-->

<div id="graphMode" class="shidden">
<button id="backToSearch" class="toggle-btn frameless !mb-2">&larr; Return to search</button>

<div id="graphExplanation" class="mb-3">
  <h1 id="graphTitle" class="mb-1">Relationship Graph</h1>
  <p class="text-sm mb-2" id="graphInstructions">
    Below is a visualization of our selected subject's relationships, color-coded by category.  
    <strong>Click any color</strong> in the legend below to toggle that category on/off. The graph will re-render automatically.  
    Click "Download SVG" to get an offline copy of the image.
  </p>
</div>

<!-- Legend for edge categories -->
<div id="legend"></div>

<!-- A spot to show short summary about the root subject from bullets.csv -->
<div id="rootSummary" class="mb-4 p-2 md:px-4 md:pt-3 border rounded text-sm bg-white"></div>

<!-- Where the graph renders -->
<div id="graph-container" class="border rounded flex items-center justify-center bg-white">
  <svg id="graph" width="100%" height="100%" preserveAspectRatio="xMidYMid meet">
    <defs>
      <marker id="arrow" viewBox="0 0 10 10" refX="5" refY="5"
        markerWidth="6" markerHeight="6" orient="auto-start-reverse">
        <path d="M 0 0 L 10 5 L 0 10 z" class="arrow-path"></path>
      </marker>
      <!-- Category-specific markers will be added dynamically by D3 -->
    </defs>
    <g id="graph-content"></g>
  </svg>
  <!-- Add loading overlay with the same styling as in expose/index.html -->
  <div id="loading" class="absolute inset-0 flex flex-col items-center justify-start bg-white pt-4 h-full z-30">
    <div class="text-center">
      <svg class="animate-spin h-8 w-8 text-navy mx-auto mb-4" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
        <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
        <path fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4z"></path>
      </svg>
      <div id="loading-text" class="text-lg font-semibold text-navy mb-4">Loading graph...</div>
      <div id="loading-nodes" class="text-gray-600 max-w-md mx-auto text-center px-4 max-h-[80vh] overflow-y-auto">
        <!-- Node names will be added here -->
      </div>
    </div>
  </div>
  <div id="loading-indicator" class="absolute">
    <img src="../assets/images/loading.svg" class="loading-spinner" style="width:32px;height:32px" alt="Loading...">
  </div>
</div>

<!-- Download button -->
<div class="mt-2 text-right">
  <button id="downloadBtn" class="toggle-btn" style="display: none;">Download SVG</button>
</div>
</div>


<script>
/***************************************
* GLOBALS
***************************************/
let allReverseIndex = new Map();      // token -> array of lineIDs (with ranges)
let allSubjects = [];                 // lines from subjects.csv (index = line-1)
let allBullets = new Map();           // subject -> { bullet_point1, bullet_point2 }
let globalSubjectsMap = new Map();    // subject name -> bullet info
let parsedRelations = [];             // parsed relations data
let parsedIntergraph = [];            // parsed intergraph edges data
let searchInProgress = false;
let searchCanceled = false;
let hasInitialDataLoaded = false;

// For Graph Mode
const NUM_PARTITIONS = 47;           
let categoryColors = {               
  "FAMILY": "#E11D48",
  "WORK": "#2563EB",
  "POLITICAL": "#9333EA",
  "LEGAL": "#DC2626",
  "MEDIA": "#EA580C",
  "EDUCATION": "#4ADE80",
  "HISTORICAL": "#D97706",
  "SOCIAL": "#14B8A6",
  "OTHER": "#6B7280",
  "UNKNOWN": "#6B7280"
};

// D3 Graph variables
let width, height;
let simulation = null;
let zoom = null;
let nodeElements = null;
let linkElements = null;
let labelElements = null;

// We store all graph edges in memory so toggling categories is easy:
let globalNodesMap = new Map();  // subject -> bullet info
let globalAllEdges = new Map();  // key -> edge object
let globalActiveCategories = new Set(); // which categories are currently on display

// Force simulation parameters
const forceParams = {
  linkDistance: 800,     // Reduced from 1200
  charge: -8000,         // Reduced from -10000
  collisionRadius: 400,   // Reduced from 500
  bounds: {
    left: 300,
    right: 300,
    top: 300,
    bottom: 300
  }
};

/***************************************
* ON LOAD
***************************************/
$(document).ready(async function() {
  // Check if we have a ?subject= param
  const urlParams = new URLSearchParams(window.location.search);
  const subj = urlParams.get('subject');

  // Show/hide respective modes
  if (subj) {
    $('#graphMode').removeClass('shidden');
  } else {
    $('#searchMode').removeClass('shidden');
  }

  // Start loading data in background
  await loadInitialData();

  // If we have ?subject=, go straight to GraphViz mode after data loads
  if (subj) {
    try {
      await renderGraphForSubject(subj);
    } catch (error) {
      console.error("Error rendering graph:", error);
      $('#statusMessage').text(`Error: ${error.message}`);
    }
  }

  // Otherwise, remain in search mode, but if the user typed any text in ?search= param, do that:
  const searchParam = urlParams.get('search');
  if (!subj && searchParam) {
    $('#searchBox').val(searchParam);
    $('#searchForm').trigger('submit');
  }
});


/***************************************
* Load initial data: reverse_index, subjects.csv, bullets.csv
***************************************/
async function loadInitialData() {
  if (hasInitialDataLoaded) return;
  $('#statusMessage').text('Loading data...');

  try {
    // Show spinner
    $('#searchButton .button-text').hide();
    $('#searchButton .loading-spinner').show();
    $('#searchButton').prop('disabled', true);

    // 1) Load reverse_index.txt
    await loadReverseIndex("reverse_index.txt");

    // 2) Load subjects.csv (from subjects.csv.zip)
    await loadSubjectsCSV("subjects.csv.zip", "subjects.csv");

    // 3) Load bullets.csv (from bullets.csv.zip)
    await loadBulletsCSV("bullets.csv.zip", "bullets.csv");

    hasInitialDataLoaded = true;
    $('#statusMessage').empty();
  } catch (err) {
    console.error(err);
    $('#statusMessage').text("Error: " + err);
  } finally {
    // Hide spinner
    $('#searchButton .loading-spinner').hide();
    $('#searchButton .button-text').show();
    $('#searchButton').prop('disabled', false);
  }
}

async function loadReverseIndex(txtUrl) {
  // If it's zipped, do fetch -> JSZip -> read string. 
  // For demo, assume it's just "reverse_index.txt".
  const resp = await fetch(txtUrl);
  if (!resp.ok) throw new Error(`Could not fetch ${txtUrl}`);
  const text = await resp.text();

  // parse lines like "aaron:75-110,6194,8048,13186,20098,34603"
  const lines = text.split(/\r?\n/);
  for (let line of lines) {
    line = line.trim();
    if (!line) continue;
    const parts = line.split(':');
    if (parts.length !== 2) continue;
    const token = parts[0];
    const ranges = parts[1].split(',');

    let lineIDs = [];
    for (let r of ranges) {
      if (r.includes('-')) {
        const [start, end] = r.split('-').map(x=>parseInt(x,10));
        for (let i=start; i<=end; i++) {
          lineIDs.push(i);
        }
      } else {
        let val = parseInt(r, 10);
        if (!isNaN(val)) {
          lineIDs.push(val);
        }
      }
    }
    if (!allReverseIndex.has(token)) {
      allReverseIndex.set(token, []);
    }
    allReverseIndex.get(token).push(...lineIDs);
  }
}

async function loadSubjectsCSV(zipUrl, csvFile) {
  const resp = await fetch(zipUrl);
  if (!resp.ok) throw new Error('Could not fetch ' + zipUrl);
  const buffer = await resp.arrayBuffer();

  const z = await JSZip.loadAsync(buffer);
  if (!z.file(csvFile)) throw new Error(`Missing file ${csvFile} in zip.`);

  const csvData = await z.file(csvFile).async('string');
  const parsed = Papa.parse(csvData, {
    header: true,
    skipEmptyLines: true
  });
  allSubjects = parsed.data; 
}

async function loadBulletsCSV(zipUrl, csvFile) {
  const resp = await fetch(zipUrl);
  if (!resp.ok) throw new Error('Could not fetch ' + zipUrl);
  const buffer = await resp.arrayBuffer();

  const z = await JSZip.loadAsync(buffer);
  if (!z.file(csvFile)) throw new Error(`Missing file ${csvFile} in zip.`);

  const csvData = await z.file(csvFile).async('string');
  const parsed = Papa.parse(csvData, {
    header: true,
    skipEmptyLines: true
  });

  for (let row of parsed.data) {
    const s = row['subject']?.trim() ?? '';
    if (!s) continue;
    const bulletInfo = {
      bullet_point1: row['bullet_point1'] || '',
      bullet_point2: row['bullet_point2'] || ''
    };
    allBullets.set(s, bulletInfo);
    globalSubjectsMap.set(s, bulletInfo);
  }
}

// Function to load relations data for a specific subject
async function loadRelationsData(subjectName) {
  try {
    // figure out which partition
    const partitionIdx = partitionIndex(subjectName);
    let pStr = partitionIdx.toString().padStart(2,'0');
    const relationsZip = `relations_${pStr}.zip`;
    
    console.log(`Loading relations data for ${subjectName} from ${relationsZip}`);
    
    const resp = await fetch(relationsZip);
    if (!resp.ok) {
      throw new Error(`Unable to fetch ${relationsZip}: ${resp.status} ${resp.statusText}`);
    }
    
    const buffer = await resp.arrayBuffer();
    const z = await JSZip.loadAsync(buffer);
    
    // Check if files exist in the zip
    if (!z.file('relations.csv')) {
      throw new Error(`Missing relations.csv in ${relationsZip}`);
    }
    
    // Parse relations.csv
    const relationsCsv = await z.file('relations.csv').async('string');
    parsedRelations = Papa.parse(relationsCsv, { 
      header: true, 
      skipEmptyLines: true 
    }).data;
    
    console.log(`Loaded ${parsedRelations.length} relations`);
    
    // Optionally load intergraph_edges.csv if it exists
    if (z.file('intergraph_edges.csv')) {
      const interCsv = await z.file('intergraph_edges.csv').async('string');
      parsedIntergraph = Papa.parse(interCsv, { 
        header: true, 
        skipEmptyLines: true 
      }).data;
      console.log(`Loaded ${parsedIntergraph.length} intergraph edges`);
    } else {
      console.log('No intergraph_edges.csv found in zip');
      parsedIntergraph = [];
    }
    
    return true;
  } catch (error) {
    console.error("Error loading relations data:", error);
    $('#statusMessage').text(`Error loading relations: ${error.message}`);
    throw error;
  }
}

// Helper function to determine which partition a subject belongs to
function partitionIndex(subject) {
  // Use murmur hash to determine partition
  const hash = murmurHash3.x86.hash32(subject);
  return Math.abs(hash) % NUM_PARTITIONS;
}


/***************************************
* SEARCH FORM
***************************************/
$('#searchForm').on('submit', async function(e) {
  e.preventDefault();
  if (searchInProgress) {
    // If in progress, let user cancel
    searchCanceled = true;
    return;
  }
  searchCanceled = false;
  searchInProgress = true;

  // clear old results
  $('#resultsContainer').empty();
  $('#resultsStatus').empty();

  // show spinner
  $('#searchButton .button-text').text("Stop");
  $('#searchBox').prop('disabled', true);

  try {
    await doSearch();
  } catch (err) {
    console.error(err);
    $('#resultsContainer').html(`<div class="p-2 text-center text-sm text-red-500">Error: ${err}</div>`);
  }

  // restore
  searchInProgress = false;
  $('#searchButton .button-text').text("Search");
  $('#searchBox').prop('disabled', false);
});


async function doSearch() {
  const rawInput = $('#searchBox').val().toLowerCase().trim();
  if (!rawInput) {
    $('#resultsContainer').html('<div class="p-2 text-center text-sm">No input provided.</div>');
    return;
  }

  // update URL param ?search= 
  const newUrl = new URL(window.location);
  newUrl.searchParams.delete('subject');
  newUrl.searchParams.set('search', rawInput);
  window.history.pushState({}, '', newUrl);

  // tokenize
  let tokens = tokenizeInput(rawInput);

  // intersect sets
  let finalLineSet = null;
  for (let t of tokens) {
    if (searchCanceled) break;

    let linesForT = new Set();
    // exact matches
    if (allReverseIndex.has(t)) {
      for (let ln of allReverseIndex.get(t)) {
        linesForT.add(ln);
      }
    }
    // prefix if box is checked
    if ($('#prefixCheck').is(':checked') && t.length >= 4) {
      // find anything that starts with t
      for (let [kw, lines] of allReverseIndex.entries()) {
        if (kw.startsWith(t) && kw !== t) {
          for (let ln of lines) {
            linesForT.add(ln);
          }
        }
      }
    }

    // intersect
    if (finalLineSet === null) {
      finalLineSet = linesForT;
    } else {
      let tmp = new Set();
      for (let x of finalLineSet) {
        if (linesForT.has(x)) tmp.add(x);
      }
      finalLineSet = tmp;
    }
    if (!finalLineSet.size) break;
  }

  if (!finalLineSet || !finalLineSet.size) {
    $('#resultsContainer').html('<div class="p-2 text-center text-sm">No matches found.</div>');
    return;
  }

  let sortedLines = Array.from(finalLineSet).sort((a,b)=>a-b);
  let limit = 100;
  let displayed = 0;

  for (let ln of sortedLines) {
    if (searchCanceled) break;
    if (displayed >= limit) break;

    let idx = ln - 1;
    if (idx >= 0 && idx < allSubjects.length) {
      let row = allSubjects[idx];
      let subject = row['subject'] || '';
      let desc = row['bullet_point1'] || '';
      $('#resultsContainer').append(renderSearchResult(subject, desc));
      displayed++;
    }
  }

  if (displayed > 0) {
    let extra = searchCanceled ? ' (stopped)' : (displayed === limit ? ' (limit)' : '');
    $('#resultsStatus').text(`Showing ${displayed}${extra} results`);
  } else {
    $('#resultsContainer').html('<div class="p-2 text-center text-sm">No results found.</div>');
  }
}

function tokenizeInput(txt) {
  // remove non-alphanumeric except for ' and "
  txt = txt.replace(/[^\w\s"']+/g, ' ');
  return txt.split(/\s+/).filter(Boolean);
}

function renderSearchResult(subject, desc) {
  const safeSubject = escapeHtml(subject);
  const safeDesc = escapeHtml(desc);

  let $div = $(`
    <div class="group border border-gray-200 hover:border-gray-400 bg-white rounded p-2 md:px-4 leading-tight">
      <strong class="text-navy group-hover:text-blue text-sm">${safeSubject}</strong><br/>
      <span class="text-[13px]">${safeDesc}</span>
    </div>
  `);

  $div.css('cursor','pointer').on('click', function() {
    window.location.href = '?subject=' + encodeURIComponent(subject);
  });

  return $div;
}


/***************************************
* BACK TO SEARCH
***************************************/
$('#backToSearch').on('click', function() {
  const newUrl = new URL(window.location);
  newUrl.searchParams.delete('subject');
  window.history.pushState({}, '', newUrl);
  window.location.reload();
});


/***************************************
* GRAPH MODE
***************************************/
async function renderGraphForSubject(subjectName) {
  try {
    // Show loading indicator
    $('#loading-indicator').show();
    $('#graphInstructions').hide();
    
    // Clear any previous error messages
    $('#graph-container').removeClass('error');
    
    // Get the subject data
    const subject = globalSubjectsMap.get(subjectName);
    if (!subject) {
      throw new Error(`Subject "${subjectName}" not found`);
    }
    
    // Populate the root summary div with bullet points
    const rootSummaryHtml = [];
    if (subject.bullet_point1) {
      rootSummaryHtml.push(`<p class="mb-1">${escapeHtml(subject.bullet_point1)}</p>`);
    }
    if (subject.bullet_point2) {
      rootSummaryHtml.push(`<p>${escapeHtml(subject.bullet_point2)}</p>`);
    }
    // If no bullet points, add a default message
    if (rootSummaryHtml.length === 0) {
      rootSummaryHtml.push(`<p class="text-gray-500 italic">No detailed information available for ${escapeHtml(subjectName)}.</p>`);
    }
    // Add a title for the summary
    $('#rootSummary').html(`
      <h3 class="font-bold mt-0 mb-2 text-navy">${escapeHtml(subjectName)}</h3>
      ${rootSummaryHtml.join('')}
    `);
    
    // Load relations data for this subject
    await loadRelationsData(subjectName);
    
    // Reset global variables
    globalNodesMap = new Map();
    globalAllEdges = new Map();
    
    // Create nodes and edges for the graph
    const nodes = [];
    const edges = [];
    const edgesSet = new Set();
    
    // Add the root subject node
    const rootNode = {
      id: subjectName,
      bulletInfo: subject
    };
    nodes.push(rootNode);

    // 1) Forward edges
    for (let row of parsedRelations) {
      let s = row.subject?.trim() || "";
      let o = row.object?.trim() || "";
      if (s !== subjectName) continue;
      if (!o) continue;
      
      // Skip self-loops
      if (s === o) continue;
      
      // Check if we should skip symmetrical duplicates
      if (parseInt(row.is_symmetrical,10)===1) {
        let hasMirror = parsedRelations.some(rel => {
          return (rel.subject?.trim() === o && rel.object?.trim() === s);
        });
        if (hasMirror && s > o) continue;
      }

      addNodeIfNeeded(globalNodesMap, o);
      let c = row.category?.trim() || "UNKNOWN";
      let color = categoryColors[c] || categoryColors["UNKNOWN"];
      addEdge(edgesSet, globalAllEdges, s, o, (row.label||""), c, color);
    }

    // 2) Reverse edges
    for (let revRow of parsedRelations) {
      let s = revRow.subject?.trim() || "";
      let o = revRow.object?.trim() || "";
      if (o !== subjectName) continue;
      if (!s) continue;

      // Skip self-loops
      if (s === o) continue;
      
      // Check if we should skip symmetrical duplicates
      if (parseInt(revRow.is_symmetrical,10)===1) {
        let hasMirror = parsedRelations.some(rel => {
          return (rel.subject?.trim() === subjectName && rel.object?.trim() === s);
        });
        if (hasMirror) continue;
      }
      addNodeIfNeeded(globalNodesMap, s);
      let c = revRow.category?.trim() || "UNKNOWN";
      let color = categoryColors[c] || categoryColors["UNKNOWN"];
      addEdge(edgesSet, globalAllEdges, s, subjectName, (revRow.label||""), c, color);
    }

    // 3) Intergraph edges
    const potentialEdges = [];
    for (let iRow of parsedIntergraph) {
      let rp = iRow.root_person?.trim() || "";
      if (rp !== subjectName) continue;

      let s = iRow.subject?.trim() || "";
      let o = iRow.object?.trim() || "";
      if (!s || !o) continue;

      if (globalNodesMap.has(s) && globalNodesMap.has(o)) {
        potentialEdges.push({
          from: s,
          to: o,
          label: iRow.label || "",
          symmetrical: parseInt(iRow.is_symmetrical,10)===1,
          category: iRow.category?.trim() || "UNKNOWN"
        });
      }
    }
    // Filter symmetrical duplicates
    let finalInterEdges = [];
    for (let pe of potentialEdges) {
      let swapped = potentialEdges.find(e => {
        return (e.from === pe.to && e.to === pe.from && e.symmetrical === true && pe.symmetrical === true);
      });
      if (swapped && pe.from > pe.to) {
        // skip
        continue;
      }
      finalInterEdges.push(pe);
    }
    
    // Add intergraph edges
    for (let ie of finalInterEdges) {
      let c = ie.category;
      let color = categoryColors[c] || categoryColors["UNKNOWN"];
      addEdge(edgesSet, globalAllEdges, ie.from, ie.to, ie.label, c, color);
    }
    
    // Convert nodes map to array
    for (let [id, bulletInfo] of globalNodesMap) {
      if (id === subjectName) continue; // Skip root node, already added
      nodes.push({
        id: id,
        bulletInfo: bulletInfo
      });
    }
    
    // Convert edges set to array
    for (let edgeKey of edgesSet) {
      const edge = globalAllEdges.get(edgeKey);
      if (edge) {
        edges.push(edge);
      }
    }
    
    // Collect unique categories for the legend
    const uniqueCategories = new Set();
    for (const edge of edges) {
      if (edge.category) {
        uniqueCategories.add(edge.category);
      }
    }
    
    // Initialize active categories with all categories
    globalActiveCategories = new Set(uniqueCategories);

    // Render the legend
    renderLegend(Array.from(uniqueCategories));
    
    // Render the graph
    renderD3Graph(subjectName, nodes, edges);
    
    // Update URL with subject
    const url = new URL(window.location);
    url.searchParams.set('subject', subjectName);
    window.history.pushState({}, '', url);
    
    // Update page title
    document.title = `${subjectName} - People Relations`;
    
    // Show instructions
    $('#graphInstructions').show();
  } catch (error) {
    console.error("Error loading relationships:", error);
    
    // Hide loading indicator
    $('#loading-indicator').hide();
    
    // Display error message to user
    $('#graph-container').html(`
      <div class="p-4 bg-red-50 border border-red-200 rounded-md text-red-800">
        <h3 class="font-bold mb-2">Error loading relationships:</h3>
        <p>${error.message || error}</p>
        <p class="mt-2">Please try refreshing the page or selecting a different subject.</p>
      </div>
    `);
    
    // Update instructions
    $('#graphInstructions').html(`
      <p class="text-red-600">An error occurred while loading the graph. Please try again.</p>
    `).show();
  }
}

// Build & render the DOT from globalNodesMap + filtered edges

// A function to ensure node exists
function addNodeIfNeeded(map, subject) {
  if (!map.has(subject)) {
    let bullet = allBullets.get(subject) || { bullet_point1:'', bullet_point2:'' };
    map.set(subject, bullet);
  }
}

// Deduplicate edges
function addEdge(edgesSet, edgesMap, from, to, label, category, color) {
  let key = `${from}||${to}||${category}||${label}`;
  if (edgesSet.has(key)) {
    return; // skip duplicates
  }
  edgesSet.add(key);
  
  // Store in the map with the key
  if (!(edgesMap instanceof Map)) {
    console.error("edgesMap is not a Map:", edgesMap);
    // Initialize as a Map if it's not already
    edgesMap = new Map();
  }
  
  edgesMap.set(key, { from, to, label, category, color });
}

// Partition
function partitionIndex(subj) {
  const h = murmurHash3.x86.hash32(subj);
  return h % NUM_PARTITIONS;
}

async function getZipText(zipObj, filename) {
  if (!zipObj.file(filename)) throw new Error(`Missing ${filename} in zip.`);
  return await zipObj.file(filename).async('string');
}


/***************************************

function buildDotSource(rootSubject, nodesMap, edges) {
  let dot = `digraph G {
rankdir="TB";
node [ shape=box, style="filled", fillcolor="#F3F4F6", color="#94A3B8", fontname="Arial", fontsize=13 ];
edge [ fontname="Arial", color="#DADBE7", penwidth=2, fontsize=11 ];
`;

  for (let [subj, bulletData] of nodesMap.entries()) {
    let p1Wrapped = insertLineBreaks(bulletData.bullet_point1 || "");
    let p2Wrapped = insertLineBreaks(bulletData.bullet_point2 || "");
    let subjWrapped = insertLineBreaks(subj);

    // HTML-like label
    let label = `<<table border="0" cellborder="0" cellpadding="2" cellspacing="0">
      <tr><td align="left"><b>${subjWrapped}</b></td></tr>
      ${ p1Wrapped ? `<tr><td align="left"><font point-size="10">${p1Wrapped}</font></td></tr>` : '' }
      ${ p2Wrapped ? `<tr><td align="left"><font point-size="10">${p2Wrapped}</font></td></tr>` : '' }
    </table>>`;

    if (subj === rootSubject) {
      dot += `"${subj}" [ color="#2563EB", penwidth=3, label=${label} ];\n`;
    } else {
      dot += `"${subj}" [ label=${label} ];\n`;
    }
  }

  for (let e of edges) {
    dot += `"${e.from}" -> "${e.to}" [ label="${escapeHtml(e.label)}", color="${e.color}" ];\n`;
  }

  dot += `}\n`;
  return dot;
}

function renderDot(dotSrc) {
  $('#graph-container').empty();
  let viz = new Viz();

  viz.renderSVGElement(dotSrc)
    .then(svgEl => {
      // let it fill the container
      svgEl.setAttribute('width', '100%');
      svgEl.setAttribute('height', '100%');
      svgEl.setAttribute('preserveAspectRatio', 'xMidYMid meet');

      $('#graph-container').append(svgEl);

      // enable pan/zoom
      if (panZoomInstance) {
        panZoomInstance.destroy();
      }
      panZoomInstance = svgPanZoom(svgEl, {
        zoomEnabled: true,
        controlIconsEnabled: true,
        fit: true,
        center: true
      });
      // Force another fit + center so it uses max space
      panZoomInstance.resize();
      panZoomInstance.fit();
      panZoomInstance.center();

      // show download button
      $('#downloadBtn').show();
    })
    .catch(err => {
      console.error(err);
      $('#graph-container').html(`<div class="p-2 text-center text-sm text-red-500">Error generating graph: ${err}</div>`);
    });
}


/***************************************
* LEGEND & CATEGORY TOGGLING
***************************************/
function renderLegend(categories) {
  let html = '';
  categories.sort(); // optional: sort them alphabetically
  for (let c of categories) {
    let color = categoryColors[c] || categoryColors["UNKNOWN"];
    html += `<div class="legend-item" data-cat="${c}" style="background-color: ${color};">${c}</div>`;
  }
  $('#legend').html(html);

  // Attach click handler
  $('#legend .legend-item').on('click', function() {
    let cat = $(this).data('cat');
    toggleCategory(cat);
    $(this).toggleClass('disabled', !globalActiveCategories.has(cat));
  });
}

// Toggle a category in/out of the active set
function toggleCategory(cat) {
  if (globalActiveCategories.has(cat)) {
    globalActiveCategories.delete(cat);
  } else {
    globalActiveCategories.add(cat);
  }
  
  // Update edge visibility
  linkElements.attr('visibility', d => 
    globalActiveCategories.has(d.category) ? 'visible' : 'hidden'
  );
  
  // Update label visibility
  labelElements.attr('visibility', d => 
    globalActiveCategories.has(d.category) ? 'visible' : 'hidden'
  );
  
  // Update edge marker visibility (arrows)
  linkElements.attr('marker-end', d => 
    globalActiveCategories.has(d.category) 
      ? `url(#arrow-${d.category || 'UNKNOWN'})` 
      : 'none'
  );
  
  // Update legend items visual state
  $('.legend-item').each(function() {
    const category = $(this).data('cat');
    $(this).toggleClass('disabled', !globalActiveCategories.has(category));
  });
}


/***************************************
* DOWNLOAD SVG
***************************************/
$('#downloadBtn').on('click', function() {
  const svgEl = document.querySelector('#graph');
  if (!svgEl) {
    alert('No SVG to download');
    return;
  }
  
  // Create a clone of the SVG to modify for download
  const clonedSvg = svgEl.cloneNode(true);
  
  // Set explicit width and height
  clonedSvg.setAttribute('width', width);
  clonedSvg.setAttribute('height', height);
  
  // Reset the transform to ensure the graph is centered
  const content = clonedSvg.querySelector('#graph-content');
  if (content) {
    content.setAttribute('transform', `translate(${width/2}, ${height/2})`);
  }
  
  // Convert to string
  const svgData = new XMLSerializer().serializeToString(clonedSvg);
  const blob = new Blob([svgData], { type: 'image/svg+xml;charset=utf-8' });
  const url = URL.createObjectURL(blob);

  let link = document.createElement('a');
  link.href = url;
  link.download = 'relation_graph.svg';
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
  URL.revokeObjectURL(url);
});


/***************************************
* HELPER
***************************************/
function escapeHtml(str) {
  if (!str) return '';
  return str
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;');
}

/***************************************
* D3 GRAPH RENDERING
***************************************/
function initializeD3Graph() {
  // Get container dimensions
  const container = document.getElementById('graph-container');
  width = container.clientWidth;
  height = container.clientHeight;
  
  // Set the SVG viewBox to cover the entire container
  d3.select('#graph')
    .attr('viewBox', `${-width/1.5} ${-height/1.5} ${width*1.5} ${height*1.5}`)
    .attr('preserveAspectRatio', 'xMidYMid meet');
  
  // Initialize zoom behavior
  zoom = d3.zoom()
    .scaleExtent([0.1, 2])
    .on('zoom', (event) => {
      d3.select('#graph-content').attr('transform', event.transform);
    });
  
  // Apply zoom behavior to SVG
  d3.select('#graph')
    .call(zoom)
    .on('dblclick.zoom', null); // Disable double-click zoom
    
  // Center the graph with a moderate scale factor
  resetZoom();
  
  // Show loading indicator
  $('#loading-indicator').show();
}

function resetZoom() {
  // Center the graph with an appropriate scale for hierarchical layout
  // In hierarchical layout, we want to center more towards the top where the root node is
  d3.select('#graph').call(
    zoom.transform,
    d3.zoomIdentity.translate(0, height * -0.1).scale(0.5) // Move even higher by using negative value
  );
}

function renderD3Graph(rootSubject, nodes, edges) {
  // Clear previous graph
  d3.select('#graph-content').selectAll('*').remove();
  
  // Hide loading indicator when rendering starts
  $('#loading-indicator').hide();
  // Note: We keep the main 'loading' overlay visible until the graph is fully centered
  // That will be hidden in the centerGraph function when "Graph centered based on actual bounds" is logged
  
  // Update loading text to show that the graph is being processed
  $('#loading-text').text('Analyzing connections...');
  
  // Remove the premature timeout - we'll let the centerGraph function handle hiding the overlay
  // instead of this fixed 10-second timer
  
  // Initialize container dimensions
  const container = document.getElementById('graph-container');
  width = container.clientWidth;
  height = container.clientHeight;
  
  // Make edges available globally to prevent "edges is not defined" errors
  window.edges = edges;
  
  // Initialize zoom behavior if not already done
  if (!zoom) {
    zoom = d3.zoom()
      .scaleExtent([0.1, 2])
      .on('zoom', (event) => {
        d3.select('#graph-content').attr('transform', event.transform);
      });
    
    // Apply zoom behavior to SVG
    d3.select('#graph')
      .call(zoom)
      .on('dblclick.zoom', null); // Disable double-click zoom
  }
  
  // Reset zoom and pan with centered graph
  d3.select('#graph').call(
    zoom.transform,
    d3.zoomIdentity.translate(0, -height * 0.25).scale(0.5) // Increase negative offset to move higher
  );
  
  // Create the graph content group with initial transform
  const g = d3.select('#graph-content');
  
  // Explicitly set an initial transform on the graph content to center it
  g.attr('transform', `translate(${width/2}, ${height/4})`); // Position at 1/4 height instead of 1/3
  
  // Store the root subject for reference in other functions
  window.rootSubject = rootSubject;
  
  // Separate root node from other nodes
  const rootNode = nodes.find(n => n.id === rootSubject);
  const nonRootNodes = nodes.filter(n => n.id !== rootSubject);
  
  // Create a map of node IDs for quick lookup - make it global for other functions to use
  window.nodeMap = new Map();
  nodes.forEach(node => {
    nodeMap.set(node.id, node);
  });
  
  // Position root node at the top center
  if (rootNode) {
    rootNode.x = 0; // Center horizontally
    rootNode.y = -height * 0.7; // Increased negative value to position even higher
    rootNode.fx = 0; // Fix position horizontally
    rootNode.fy = -height * 0.7; // Increased negative value to position even higher
  }
  
  // Arrange non-root nodes in a semi-circle below the root node
  const radius = Math.min(width, height) * 0.25; // Use 25% of the smaller dimension for radius
  nonRootNodes.forEach((node, i) => {
    // Use a semi-circle (180 degrees) below the root
    const angle = (Math.PI * i) / (nonRootNodes.length - 1);
    node.x = radius * Math.cos(angle); // Position in semi-circle
    node.y = -height * 0.7 + radius * Math.sin(angle) + radius; // Position below root node
  });
  
  // Preprocess edges to ensure all source and target nodes exist
  console.log(`Processing ${edges.length} edges...`);
  
  // Create validEdges variable that references the edges array
  // This ensures validEdges is defined for any code that references it
  const validEdges = edges.filter(edge => {
    const sourceId = edge.from;
    const targetId = edge.to;
    
    // Check if source and target nodes exist
    const sourceExists = nodeMap.has(sourceId);
    const targetExists = nodeMap.has(targetId);
    
    if (!sourceExists) {
      console.warn(`Edge source node not found: ${sourceId}`);
    }
    if (!targetExists) {
      console.warn(`Edge target node not found: ${targetId}`);
    }
    
    // Only keep edges where both nodes exist
    if (sourceExists && targetExists) {
      // Set source and target properties for D3
      edge.source = sourceId;
      edge.target = targetId;
      return true;
    }
    return false;
  });
  
  console.log(`Filtered to ${validEdges.length} valid edges`);
  
  // Identify first-level nodes (directly connected to root)
  window.firstLevelNodeIds = new Set();
  validEdges.forEach(edge => {
    if (edge.from === rootSubject) {
      firstLevelNodeIds.add(edge.to);
      console.log(`Added first-level node from root: ${edge.to} via relation: ${edge.label || "unlabeled"}`);
    } else if (edge.to === rootSubject) {
      firstLevelNodeIds.add(edge.from);
      console.log(`Added first-level node to root: ${edge.from} via relation: ${edge.label || "unlabeled"}`);
    }
  });
  
  console.log(`Identified ${firstLevelNodeIds.size} first-level nodes`);
  console.log('First-level nodes:', Array.from(firstLevelNodeIds));
  
  // We'll call displayNodesProgressively() after nodeElements is defined
  
  // Add arrow markers for links
  const defs = g.append('defs');
  
  // Create marker definitions for each category
  Object.entries(categoryColors).forEach(([category, color]) => {
    defs.append('marker')
      .attr('id', `arrow-${category}`)
      .attr('viewBox', '0 -5 10 10')
      .attr('refX', 20)
      .attr('refY', 0)
      .attr('markerWidth', 8)
      .attr('markerHeight', 8)
      .attr('orient', 'auto')
      .append('path')
      .attr('fill', color)
      .attr('d', 'M0,-5L10,0L0,5');
  });
  
  // Regular arrow marker (fallback)
  defs.append('marker')
    .attr('id', 'arrow')
    .attr('viewBox', '0 -5 10 10')
    .attr('refX', 20)
    .attr('refY', 0)
    .attr('markerWidth', 8)
    .attr('markerHeight', 8)
    .attr('orient', 'auto')
    .append('path')
    .attr('fill', '#94A3B8')  // Default gray color
    .attr('d', 'M0,-5L10,0L0,5');
  
  // Create links
  linkElements = g.append('g')
    .attr('class', 'links')
    .selectAll('path')
    .data(validEdges)
    .join('path')
    .attr('class', 'link')
    .attr('stroke', d => {
      // Get the color from the category using the global categoryColors
      return categoryColors[d.category] || categoryColors["UNKNOWN"];
    })
    .attr('stroke-width', 2)
    .attr('marker-end', d => `url(#arrow-${d.category || 'UNKNOWN'})`)
    .attr('data-source', d => d.from)
    .attr('data-target', d => d.to)
    .attr('data-category', d => d.category)
    .style('cursor', 'pointer')
    .on('mouseover', function(event, d) {
      console.log('Link path hover:', d);
      
      // Get source and target IDs
      const sourceId = d.from;
      const targetId = d.to;
      
      // Highlight this connection
      highlightConnection(sourceId, targetId);
    })
    .on('mouseout', function() {
      console.log('Link path mouseout');
      resetHighlights();
    });
  
  // Create nodes
  nodeElements = g.append('g')
    .attr('class', 'nodes')
    .selectAll('g')
    .data(nodes)
    .join('g')
    .attr('class', d => d.id === rootSubject ? 'node root' : 'node')
    .attr('data-id', d => d.id)
    .call(d3.drag()
      .on('start', dragStarted)
      .on('drag', dragged)
      .on('end', dragEnded)
    );
   
  // Start displaying first-level nodes progressively now that nodeElements is defined
  displayNodesProgressively();
  
  // Add rectangles to nodes
  nodeElements.append('rect')
    .attr('rx', 4)
    .attr('ry', 4)
    .attr('width', d => getNodeWidth(d))
    .attr('height', d => getNodeHeight(d))
    .attr('fill', 'white')
    .attr('stroke', d => d.id === rootSubject ? '#2563EB' : '#94A3B8')
    .attr('stroke-width', d => d.id === rootSubject ? 3 : 1)
    .style('cursor', 'grab')
    .on('mouseover', function(event, d) {
      console.log('Node rect hover:', d);
      
      // Highlight all connections to/from this node
      highlightNodeConnections(d.id);
    })
    .on('mouseout', function() {
      console.log('Node rect mouseout');
      resetHighlights();
    });
    
  // Add text to nodes
  nodeElements.each(function(d) {
    const node = d3.select(this);
    const bulletInfo = d.bulletInfo || {};
    const padding = 12;
    let y = padding;
    
    // Calculate node width for text wrapping
    const nodeWidth = getNodeWidth(d);
    const maxCharsPerLine = Math.floor((nodeWidth - padding * 2) / 6.5); // Adjusted chars per line
    
    // Add subject name
    node.append('text')
      .attr('x', padding)
      .attr('y', y + 15)
      .attr('font-weight', 'bold')
      .attr('font-size', '14px')
      .text(d.id);
    y += 25;
    
    // Add bullet point 1 if available
    if (bulletInfo && bulletInfo.bullet_point1) {
      const wrappedText = wrapText(bulletInfo.bullet_point1, maxCharsPerLine);
      wrappedText.forEach(line => {
        node.append('text')
          .attr('x', padding)
          .attr('y', y + 12)
          .attr('font-size', '12px')
          .text(line);
        y += 18;
      });
    }
    
    // Add bullet point 2 if available
    if (bulletInfo && bulletInfo.bullet_point2) {
      y += 5; // Add a little extra space
      const wrappedText = wrapText(bulletInfo.bullet_point2, maxCharsPerLine);
      wrappedText.forEach(line => {
        node.append('text')
          .attr('x', padding)
          .attr('y', y + 12)
          .attr('font-size', '12px')
          .text(line);
        y += 18;
      });
    }
  });
    
  // Create edge labels
  const labelGroup = g.append('g').attr('class', 'label-group');
  labelElements = labelGroup.selectAll('g')
    .data(validEdges)
    .join('g')
    .attr('class', 'link-label-group')
    .attr('data-source', d => d.from)
    .attr('data-target', d => d.to);
  
  // Add background pill for labels
  labelElements.append('rect')
    .attr('rx', 12)
    .attr('ry', 12)
    .attr('class', 'label-bg')
    .attr('fill', '#F3F4F6')
    .attr('width', 10) // Initial size, will be updated in ticked
    .attr('height', 10)
    .attr('x', -5)
    .attr('y', -5)
    .style('cursor', 'pointer')
    .on('mouseover', function(event, d) {
      console.log('Label bg hover:', d);
      
      // Highlight this connection
      highlightConnection(d.from, d.to);
      
      // Highlight the specific path
      linkElements.filter(l => l.from === d.from && l.to === d.to)
        .attr('stroke-width', 4)
        .attr('stroke-opacity', 1);
    })
    .on('mouseout', function(event, d) {
      console.log('Label bg mouseout');
      resetHighlights();
      
      // Restore original path styling
      linkElements.filter(l => l.from === d.from && l.to === d.to)
        .attr('stroke-width', 2)
        .attr('stroke-opacity', 0.8);
    });
    
  // Add text labels with wrapping
  labelElements.each(function(d) {
    try {
      const labelGroup = d3.select(this);
      const label = d.label || "";
      
      // Skip empty labels
      if (!label.trim()) {
        labelGroup.append('text')
          .attr('class', 'link-label')
          .attr('fill', '#475569')
          .text("");
        return;
      }
      
      // For "Son of" relationship, use special styling and don't wrap
      const isSonOfRelation = label.includes("Son of") || label.includes("Child of") || 
                             label.includes("Parent of") || label.includes("Father of") || 
                             label.includes("Mother of");
      
      if (isSonOfRelation) {
        // Use a single text element with special styling for these important relationships
        labelGroup.append('text')
          .attr('class', 'link-label relationship-label')
          .attr('fill', '#3B82F6') // Blue color for relationship labels
          .attr('text-anchor', 'middle')
          .attr('font-weight', 'bold')
          .attr('dy', '0.3em')
          .text(label);
      } else {
        // Wrap text to max 20 characters per line for other relationships
        const wrappedText = wrapText(label, 20);
        
        // Add each line of text
        wrappedText.forEach((line, i) => {
          labelGroup.append('text')
            .attr('class', 'link-label')
            .attr('fill', '#475569')
            .attr('text-anchor', 'middle') // Center text
            .attr('dy', (i - (wrappedText.length - 1) / 2) * 16)
            .text(line);
        });
      }
      
      if (!d.pathPoints) {
        return;
      }
      
      const { source, target } = d.pathPoints;
      const labelEl = d3.select(this);
      
      // Calculate basic position for labels
      let labelX, labelY;
      
      // Create a unique identifier for this edge to ensure consistent offsets
      const edgeId = `${d.from}-${d.to}`;
      // Create a hash from the edge ID to get a deterministic but varied offset
      const hash = Math.abs(edgeId.split('').reduce((a, b) => {
        a = ((a << 5) - a) + b.charCodeAt(0);
        return a & a;
      }, 0));
      
      // Get nodes from source and target IDs
      const sourceNode = nodeMap.get(d.from);
      const targetNode = nodeMap.get(d.to);
      
      // Skip if nodes not found
      if (!sourceNode || !targetNode) return;
      
      // Detect if this is a root connection
      const isRootConnection = (d.from === rootSubject || d.to === rootSubject);
      const isFromRoot = d.from === rootSubject;
      
      // Calculate the distance between nodes
      const dx = target.x - source.x;
      const dy = target.y - source.y;
      const distance = Math.sqrt(dx * dx + dy * dy);
      
      // Normalize the direction vector
      const nx = dx / distance;
      const ny = dy / distance;
      
      // Create perpendicular vector for offset
      const px = -ny;
      const py = nx;
      
      if (isRootConnection) {
        // For connections with root
        const t = isFromRoot ? 0.35 : 0.65; // Position along the path
        
        // Calculate base position along the path
        labelX = source.x + dx * t;
        labelY = source.y + dy * t;
        
        // Apply a perpendicular offset based on hash
        const perpOffset = 60 + (hash % 40); // 60-100px perpendicular offset
        labelX += px * perpOffset;
        labelY += py * perpOffset;
      } else {
        // For non-root connections, position at midpoint with perpendicular offset
        labelX = source.x + dx * 0.5;
        labelY = source.y + dy * 0.5;
        
        // Apply larger perpendicular offset based on hash
        const perpOffset = 80 + (hash % 60); // 80-140px perpendicular offset
        
        // Use a deterministic but varied sign for the offset
        const sign = ((hash % 2) * 2 - 1); // Either 1 or -1
        labelX += px * perpOffset * sign;
        labelY += py * perpOffset * sign;
      }
      
      // Get text elements to calculate size
      const textElements = labelEl.selectAll('text.link-label');
      
      if (textElements.size() > 0) {
        let labelWidth = 0;
        let labelHeight = 0;
        
        // Calculate total width and height based on all text elements
        textElements.each(function() {
          try {
            const bbox = this.getBBox();
            labelWidth = Math.max(labelWidth, bbox.width);
            labelHeight += bbox.height;
          } catch (e) {
            console.log("Error getting text bounding box", e);
          }
        });
        
        // Add more padding
        labelWidth += 30;
        labelHeight += 16;
        
        // Update background rectangle size
        labelEl.select('rect.label-bg')
          .attr('width', labelWidth)
          .attr('height', labelHeight)
          .attr('x', -labelWidth / 2)
          .attr('y', -labelHeight / 2);
        
        // Update the text position to match the background
        labelEl.attr('transform', `translate(${labelX},${labelY})`);
        
        // Store the position for use in interactions
        d.labelX = labelX;
        d.labelY = labelY;
      }
    } catch (error) {
      console.error("Error positioning label:", error);
    }
  });
  
  // Helper function to highlight a connection between two nodes
  function highlightConnection(sourceId, targetId) {
    // Find the link data to get its category color
    const linkData = linkElements.filter(l => l.from === sourceId && l.to === targetId).data()[0];
    
    if (!linkData) {
      console.warn(`No link found between ${sourceId} and ${targetId}`);
      return;
    }
    
    // Get the category color
    const categoryColor = categoryColors[linkData.category] || categoryColors["UNKNOWN"];
    
    // Highlight the link with its category color
    linkElements.filter(l => l.from === sourceId && l.to === targetId)
      .style('stroke', categoryColor)
      .style('stroke-width', '4px')
      .attr('marker-end', `url(#arrow-${linkData.category || 'UNKNOWN'})`);
    
    // Highlight source and target nodes with the same category color
    nodeElements.filter(n => n.id === sourceId)
      .select('rect')
      .style('stroke', '#2563EB')  // Source node still uses blue
      .style('stroke-width', '3px');
      
    nodeElements.filter(n => n.id === targetId)
      .select('rect')
      .style('stroke', categoryColor)  // Target node uses category color
      .style('stroke-width', '3px');
    
    // Highlight the label with the category color
    labelElements.filter(l => l.from === sourceId && l.to === targetId)
      .each(function() {
        d3.select(this).select('.label-bg')
          .style('fill', categoryColor);
        d3.select(this).selectAll('.link-label')
          .style('fill', 'white');
      });
  }
  
  // Helper function to highlight all connections to/from a node
  function highlightNodeConnections(nodeId) {
    // Highlight all links connected to this node
    linkElements.each(function(link) {
      const sourceId = link.from;
      const targetId = link.to;
      
      if (sourceId === nodeId || targetId === nodeId) {
        // Highlight this connection
        highlightConnection(sourceId, targetId);
      }
    });
  }
  
  // Helper function to reset all highlights
  function resetHighlights() {
    // Reset node styles
    nodeElements.select('rect')
      .style('stroke', null)
      .style('stroke-width', null)
      .attr('stroke', d => d.id === rootSubject ? '#2563EB' : '#94A3B8')
      .attr('stroke-width', d => d.id === rootSubject ? 3 : 1);
    
    // Reset edge styles - maintain category colors
    linkElements
      .style('stroke', null)
      .style('stroke-width', null)
      .attr('stroke', d => categoryColors[d.category] || categoryColors["UNKNOWN"])
      .attr('stroke-width', 2)
      .attr('marker-end', d => `url(#arrow-${d.category || 'UNKNOWN'})`);
    
    // Reset label styles
    labelElements.select('.label-bg')
      .style('fill', null)
      .attr('fill', '#F3F4F6');
    labelElements.selectAll('.link-label')
      .style('fill', null)
      .attr('fill', '#475569');
  }
  
  // First run the simulation without rendering for many iterations
  // This helps find a better layout before rendering
  let tempSimulation = d3.forceSimulation(nodes)
    .force('link', d3.forceLink()
      .links(edges)
      .id(d => d.id)
      .distance(d => {
        // Vary distance based on connection type
        if (d.from === rootSubject || d.to === rootSubject) {
          return 350; // Root connections get even more space
        }
        return 250; // More space for other connections
      }))
    .force('charge', d3.forceManyBody()
      .strength(d => d.id === rootSubject ? -2500 : -1500)) // Stronger repulsion
    .force('x', d3.forceX(d => {
      if (d.id === rootSubject) return 0;
      if (firstLevelNodeIds.has(d.id)) {
        return d.x * 1.7; // Push first level nodes further out horizontally
      }
      return d.x;
    }).strength(0.25))
    .force('y', d3.forceY(d => {
      if (d.id === rootSubject) return -height * 0.7; // Increased negative value for higher positioning
      if (firstLevelNodeIds.has(d.id)) {
        return d.y; // Keep first level at their y positions
      }
      return height * 0.35; // Push other nodes down more
    }).strength(0.25))
    .force('collision', d3.forceCollide()
      .radius(d => {
        // Even larger collision radius to keep nodes well separated
        const nodeWidth = getNodeWidth(d);
        const nodeHeight = getNodeHeight(d);
        
        if (d.id === rootSubject) {
          return Math.sqrt(nodeWidth * nodeHeight) + 180;
        }
        return Math.sqrt(nodeWidth * nodeHeight) + 130;
      })
      .strength(1)) // Full collision strength
    .stop();
  
  // Run the pre-positioning simulation for more iterations
  for (let i = 0; i < 50; i++) {  // Reduced from 150 to 50 iterations
    tempSimulation.tick();
  }
  
  // Now create the actual simulation for rendering
  simulation = d3.forceSimulation(nodes)
    .force('link', d3.forceLink()
      .links(edges)
      .id(d => d.id)
      .distance(d => {
        // Use different distances for different types of connections
        if (d.from === rootSubject || d.to === rootSubject) {
          return forceParams.linkDistance * 8; // Reduced from 10
        }
        return forceParams.linkDistance * 5; // Reduced from 7
      }))
    .force('charge', d3.forceManyBody()
      .strength(d => {
        // Use stronger repulsion for the root
        if (d.id === rootSubject) {
          return forceParams.charge * -15; // Reduced from -20
        }
        // Use node size to scale repulsion
        const nodeSize = Math.sqrt(getNodeWidth(d) * getNodeHeight(d));
        return forceParams.charge * (nodeSize / 150) * -10; // Reduced from -15
      })
      .distanceMin(600) // Reduced from 900
      .distanceMax(8000)) // Reduced from 12000
    .force('x', d3.forceX(d => {
      // Root node stays at center
      if (d.id === rootSubject) return 0;
      
      // First level nodes maintain their existing x position but with scaling
      if (firstLevelNodeIds.has(d.id)) {
        return d.x * 1.2; // Reduced from 1.3
      }
      
      // Second level nodes spread wider
      return d.x * 1.3; // Reduced from 1.4
    }).strength(d => d.id === rootSubject ? 1 : 0.3)) // Increased from 0.2 for faster positioning
    .force('y', d3.forceY(d => {
      // Keep root at top
      if (d.id === rootSubject) return -height * 0.7; // Increased negative value for higher positioning
      
      // First level nodes position
      if (firstLevelNodeIds.has(d.id)) {
        return d.y * 0.9; // Adjust as needed
      }
      
      // Second level nodes position
      return d.y * 1.2; // Reduced from 1.3
    }).strength(d => d.id === rootSubject ? 1 : 0.4)) // Increased from 0.35
    .force('collision', d3.forceCollide().radius(d => {
      // Use much larger collision radius
      const nodeWidth = getNodeWidth(d);
      const nodeHeight = getNodeHeight(d);
      // Different collision radii based on node type
      if (d.id === rootSubject) {
        return Math.sqrt(nodeWidth * nodeHeight) + 150; // Reduced from 180
      }
      return Math.sqrt(nodeWidth * nodeHeight) + 100; // Reduced from 130
    }).strength(0.8).iterations(2)) // Reduced iterations from 4 to 2
    .alpha(0.5) // Slightly higher alpha for faster convergence
    .alphaDecay(0.015) // Increased from 0.003 for faster convergence
    .velocityDecay(0.3) // Increased from 0.25 for slightly more damping
    .on('tick', ticked)
    .on('end', () => {
      // When the simulation ends, center the graph based on actual content bounds
      centerGraph();
      
      // We'll move the progressive display and failsafe to after centerGraph completes
      // by letting centerGraph call displayNodesProgressively
    });
}

// Function to display nodes progressively after data is fully loaded
function displayNodesProgressively() {
  try {
    const loadingNodesDiv = document.getElementById('loading-nodes');
    if (!loadingNodesDiv) {
      console.warn("Loading nodes div not found");
      return;
    }
    
    loadingNodesDiv.innerHTML = ''; // Clear any existing content
    
    // Check if nodeElements exists - if not, we can't display nodes yet
    if (!nodeElements) {
      console.warn("Node elements not available yet, cannot display nodes progressively");
      return;
    }
    
    // Get root node
    const rootNode = nodeElements.filter(d => d.id === rootSubject).data()[0];
    
    // Find first-level nodes (directly connected to root)
    // Use window.firstLevelNodeIds to ensure we access the global variable
    const firstLevelNodes = nodeElements.filter(d => window.firstLevelNodeIds.has(d.id)).data();
    
    console.log(`Displaying ${firstLevelNodes.length} first-level nodes progressively`);
    
    // Add root node first
    if (rootNode) {
      const rootDiv = document.createElement('div');
      rootDiv.className = 'opacity-0 transition-opacity duration-300 py-1';
      
      // Add the root node ID as the main text
      const nodeIdSpan = document.createElement('div');
      nodeIdSpan.className = 'font-bold';
      nodeIdSpan.textContent = rootNode.id;
      rootDiv.appendChild(nodeIdSpan);
      
      // Add text indicating this is the root node
      const relationSpan = document.createElement('div');
      relationSpan.className = 'text-sm opacity-80 ml-2';
      rootDiv.appendChild(relationSpan);
      
      loadingNodesDiv.appendChild(rootDiv);
      
      // Trigger fade in for root node
      setTimeout(() => {
        rootDiv.style.opacity = '1';
      }, 150);
    }
    
    // Function to find relationship labels between root and a node
    function getRelationshipLabels(nodeId) {
      const relationships = [];
      
      // Check for edges from root to this node
      window.edges.forEach(edge => {
        if (edge.from === rootSubject && edge.to === nodeId) {
          relationships.push(edge.label || "unlabeled relation");
        } else if (edge.to === rootSubject && edge.from === nodeId) {
          relationships.push(edge.label || "unlabeled relation");
        }
      });
      
      return relationships;
    }
    
    // Add first-level nodes progressively
    let nodeIndex = 0;
    function addNextNode() {
      if (nodeIndex < firstLevelNodes.length) {
        const node = firstLevelNodes[nodeIndex];
        
        // Create element for this node
        const div = document.createElement('div');
        div.className = 'opacity-0 transition-opacity duration-300 py-2';
        
        // Add the node ID as the main text
        const nodeIdSpan = document.createElement('div');
        nodeIdSpan.textContent = node.id;
        div.appendChild(nodeIdSpan);
        
        // Add relationship labels
        const relationships = getRelationshipLabels(node.id);
        if (relationships.length > 0) {
          relationships.forEach(label => {
            const relationSpan = document.createElement('div');
            relationSpan.className = 'text-sm opacity-80 ml-2';
            relationSpan.textContent = label;
            div.appendChild(relationSpan);
          });
        }
        
        // Add to container
        loadingNodesDiv.appendChild(div);
        
        // Trigger fade in and scroll to bottom
        setTimeout(() => {
          div.style.opacity = '1';
          loadingNodesDiv.scrollTop = loadingNodesDiv.scrollHeight;
        }, 50);
        
        // Move to next node
        nodeIndex++;
        
        // Schedule next node with 1 second delay
        setTimeout(addNextNode, 1000);
      }
    }
    
    // Start adding nodes with a short delay
    setTimeout(addNextNode, 500);
  } catch (error) {
    console.error("Error displaying nodes progressively:", error);
  }
}

// Function to center the graph based on its actual rendered bounds
function centerGraph() {
  try {
    // Get the bounding box of the graph content
    const bbox = document.getElementById('graph-content').getBBox();
    console.log("Graph bbox:", bbox);
    
    // Calculate the dimensions of the viewport
    const viewportWidth = width;
    const viewportHeight = height;
    console.log("Viewport dimensions:", viewportWidth, viewportHeight);
    
    // Calculate the center of the graph content with emphasis on the root node
    // For knowledge graphs, we want the root higher in the viewport
    const graphCenterX = bbox.x + bbox.width / 2;
    const graphCenterY = bbox.y + bbox.height * 0.15; // 15% point to shift focus even further upward
    
    // Calculate the translation needed to center the graph
    const translateX = viewportWidth / 2 - graphCenterX;
    const translateY = viewportHeight / 5 - graphCenterY; // Position at 1/5 of the height instead of 1/3
    console.log("Translation:", translateX, translateY);
    
    // Determine appropriate initial scale based on the graph size
    // We want to fit the graph with some margin
    let initialScale = Math.min(
      viewportWidth / (bbox.width * 1.25),  // 25% margin horizontally
      viewportHeight / (bbox.height * 1.25) // 25% margin vertically
    );
    
    // Limit scale to reasonable bounds
    initialScale = Math.min(Math.max(initialScale, 0.15), 0.75);
    console.log("Initial scale:", initialScale);
    
    // Update the zoom transform to center the graph with appropriate scale
    d3.select('#graph').call(
      zoom.transform,
      d3.zoomIdentity
        .translate(translateX, translateY)
        .scale(initialScale)
    );
    
    console.log("Graph centered based on actual bounds");
    
    // Now the nodes are already being displayed progressively before centering
    // so we don't need to call displayNodesProgressively here
    
    // Hide loading overlay and indicators
    document.getElementById('loading').style.display = 'none';
    $('#loading-indicator').hide();
    $('#loading-overlay').fadeOut();
  } catch (error) {
    console.error("Error centering graph:", error);
    
    // Failsafe: Ensure loading overlay is hidden even if there's an error
    document.getElementById('loading').style.display = 'none';
    $('#loading-indicator').hide();
  }
}

// Function for updating element positions on tick
function ticked() {
  try {
    // Keep the root node fixed at the top
    simulation.nodes().forEach(d => {
      if (d.id === rootSubject) {
        d.x = 0;
        d.y = -height * 0.5; // Increased to position higher (was 0.4)
        d.fx = 0;
        d.fy = -height * 0.5; // Increased to position higher (was 0.4)
      }
    });
    
    // Get the bounds of the available canvas area
    const graphWidth = width * 2;  // Make the bounding box larger than the visible area
    const graphHeight = height * 2;
    
    // Add border constraints - keep nodes within bounds
    simulation.nodes().forEach(function(d) {
      // Don't apply to fixed nodes (like the root)
      if (d.fx !== undefined || d.fy !== undefined) return;
      
      // Don't let nodes go too far off-canvas
      const nodeWidth = getNodeWidth(d);
      const nodeHeight = getNodeHeight(d);
      
      // Softer constraints - gradually increase force as nodes approach edges
      const margin = 200; // Increased margin
      
      // X bounds
      const xMin = -graphWidth/2 + nodeWidth/2 + margin;
      const xMax = graphWidth/2 - nodeWidth/2 - margin;
      
      // Y bounds - allow more space at the top for the hierarchical layout
      const yMin = -graphHeight/2 + nodeHeight/2 + margin;
      const yMax = graphHeight/2 - nodeHeight/2 - margin;
      
      if (d.x < xMin) {
        d.x = xMin + (d.x - xMin) * 0.1; // gradual enforcement
        d.vx = Math.abs(d.vx) * 0.5; // dampen velocity and reverse direction
      }
      if (d.x > xMax) {
        d.x = xMax - (xMax - d.x) * 0.1; // gradual enforcement
        d.vx = -Math.abs(d.vx) * 0.5; // dampen velocity and reverse direction
      }
      
      if (d.y < yMin) {
        d.y = yMin + (d.y - yMin) * 0.1; // gradual enforcement
        d.vy = Math.abs(d.vy) * 0.5; // dampen velocity and reverse direction
      }
      if (d.y > yMax) {
        d.y = yMax - (yMax - d.y) * 0.1; // gradual enforcement
        d.vy = -Math.abs(d.vy) * 0.5; // dampen velocity and reverse direction
      }
    });
    
    // Update node positions
    nodeElements.attr('transform', d => `translate(${d.x - getNodeWidth(d) / 2},${d.y - getNodeHeight(d) / 2})`);
    
    // Helper function to get node layer for path generation
    function getNodeLayer(nodeId, edgesList) {
      // Root is always layer 0
      if (nodeId === rootSubject) return 0;
      
      // First level: directly connected to root
      const isConnectedToRoot = edgesList.some(e => 
        (e.from === rootSubject && e.to === nodeId) || 
        (e.to === rootSubject && e.from === nodeId)
      );
      
      if (isConnectedToRoot) return 1;
      
      // Otherwise it's a deeper level
      return 2;
    }
    
    // Update link positions with more advanced path generation
    linkElements.attr('d', function(d) {
      try {
        const sourceId = d.from;
        const targetId = d.to;
        
        // Get source and target nodes from the ID
        const sourceNode = nodeMap.get(sourceId);
        const targetNode = nodeMap.get(targetId);
        
        if (!sourceNode || !targetNode) {
          console.warn(`Missing node data for ${sourceId} or ${targetId}`);
          return '';
        }
        
        // Calculate source and target points
        const sourcePoint = {
          x: sourceNode.x,
          y: sourceNode.y
        };
        
        const targetPoint = {
          x: targetNode.x,
          y: targetNode.y
        };
        
        // Store the source and target points for label positioning
        d.pathPoints = { source: sourcePoint, target: targetPoint };
        
        // Direct line for debugging
        if (window.debugMode) {
          const sourceX = sourceNode.x;
          const sourceY = sourceNode.y;
          const targetX = targetNode.x;
          const targetY = targetNode.y;
          return `M${sourceX},${sourceY} L${targetX},${targetY}`;
        }
        
        // Adjust path drawing based on whether this is a connection from/to root
        const isRootConnection = (sourceId === rootSubject || targetId === rootSubject);
        
        // Check if this is a "Son of" relationship
        const isSonOfRelation = d.label && (d.label.includes("Son of") || d.label.includes("Child of") || d.label.includes("Parent of") || d.label.includes("Father of") || d.label.includes("Mother of"));
        
        // Create path with more segments for hierarchical flow
        let path = '';
        
        // For "Son of" relations, use a more prominent curve
        if (isSonOfRelation) {
          // Calculate midpoint with offset for a nice curve
          const midX = (sourcePoint.x + targetPoint.x) / 2;
          const midY = (sourcePoint.y + targetPoint.y) / 2;
          
          // Calculate a perpendicular vector to the line
          const dx = targetPoint.x - sourcePoint.x;
          const dy = targetPoint.y - sourcePoint.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          
          // Normalize and get perpendicular vector
          const nx = dx / dist;
          const ny = dy / dist;
          const px = -ny;
          const py = nx;
          
          // Create a large curve for "Son of" relationships
          // The curve should extend away from the direct line to make space for the label
          const curveOffset = dist * 0.3; // 30% of distance as curve height
          
          // Apply the curve offset
          const ctrlX = midX + px * curveOffset;
          const ctrlY = midY + py * curveOffset;
          
          // Use a quadratic curve for "Son of" relationships
          path = `M${sourcePoint.x},${sourcePoint.y} Q${ctrlX},${ctrlY} ${targetPoint.x},${targetPoint.y}`;
          
          // Store control points for label positioning
          d.curveControlPoints = { ctrlX, ctrlY };
        }
        // For hierarchical layout, use different path strategies
        else if (isRootConnection) {
          // For connections involving the root, use more direct paths
          if (sourceId === rootSubject) {
            // Root to other nodes - create more spread out curves
            const controlDistance = Math.abs(targetPoint.x - sourcePoint.x) * 0.3;
            const midY = sourcePoint.y + (targetPoint.y - sourcePoint.y) * 0.4;
            
            // Use bezier curves with control points that spread out more
            path = `M${sourcePoint.x},${sourcePoint.y} 
                    C${sourcePoint.x},${sourcePoint.y + controlDistance} 
                    ${targetPoint.x},${targetPoint.y - controlDistance} 
                    ${targetPoint.x},${targetPoint.y}`;
            
            // Store control points for label positioning
            d.curveControlPoints = { 
              ctrl1X: sourcePoint.x, 
              ctrl1Y: sourcePoint.y + controlDistance,
              ctrl2X: targetPoint.x, 
              ctrl2Y: targetPoint.y - controlDistance 
            };
          } else {
            // Other nodes to root - create more spread out curves going upward
            const controlDistance = Math.abs(sourcePoint.x - targetPoint.x) * 0.3;
            
            // Use bezier curves with control points that spread out more
            path = `M${sourcePoint.x},${sourcePoint.y} 
                    C${sourcePoint.x},${sourcePoint.y - controlDistance} 
                    ${targetPoint.x},${targetPoint.y + controlDistance} 
                    ${targetPoint.x},${targetPoint.y}`;
            
            // Store control points for label positioning
            d.curveControlPoints = { 
              ctrl1X: sourcePoint.x, 
              ctrl1Y: sourcePoint.y - controlDistance,
              ctrl2X: targetPoint.x, 
              ctrl2Y: targetPoint.y + controlDistance 
            };
          }
        } else {
          // For connections between non-root nodes
          // Calculate the "layer" of the node based on its position
          const sourceLayer = getNodeLayer(sourceId, edges);
          const targetLayer = getNodeLayer(targetId, edges);
          
          // Route differently based on whether nodes are on same layer or different layers
          if (Math.abs(sourcePoint.y - targetPoint.y) > Math.abs(sourcePoint.x - targetPoint.x) * 1.2) {
            // More vertical than horizontal - likely across layers
            // Use S-curves for more separation between paths
            const dx = targetPoint.x - sourcePoint.x;
            const dy = targetPoint.y - sourcePoint.y;
            
            // Calculate offset based on the uniqueness of the connection
            const connectionId = sourceId.length + targetId.length + sourcePoint.x;
            const randomOffset = (connectionId % 100) / 100 * 0.4 + 0.3; // 0.3 to 0.7 range
            
            // Create control points for S-curve
            const cp1x = sourcePoint.x + dx * 0.1;
            const cp1y = sourcePoint.y + dy * randomOffset;
            const cp2x = sourcePoint.x + dx * 0.9;
            const cp2y = sourcePoint.y + dy * (1 - randomOffset);
            
            path = `M${sourcePoint.x},${sourcePoint.y} 
                    C${cp1x},${cp1y} ${cp2x},${cp2y} ${targetPoint.x},${targetPoint.y}`;
          } else if (Math.abs(sourceLayer - targetLayer) <= 1) {
            // Nodes are on similar layers - use a curved path
            const midX = (sourcePoint.x + targetPoint.x) / 2;
            // Add some randomness to midY to reduce overlaps
            const midYOffset = (sourceId.length + targetId.length) % 100;
            const midY = (sourcePoint.y + targetPoint.y) / 2 + (midYOffset - 50);
            
            path = `M${sourcePoint.x},${sourcePoint.y} 
                    Q${midX},${midY} ${targetPoint.x},${targetPoint.y}`;
          } else {
            // Significant horizontal distance - use orthogonal routing with randomized midpoints
            const midX = (sourcePoint.x + targetPoint.x) / 2 + 
                      ((sourceId.length * targetId.length) % 100 - 50);
            const yDiff = Math.abs(targetPoint.y - sourcePoint.y);
            const midY1 = sourcePoint.y + (isSourceHigher ? yDiff * 0.25 : -yDiff * 0.25);
            const midY2 = targetPoint.y + (isSourceHigher ? -yDiff * 0.25 : yDiff * 0.25);
            
            path = `M${sourcePoint.x},${sourcePoint.y} 
                    C${sourcePoint.x},${midY1} ${midX},${midY1} ${midX},${(midY1 + midY2) / 2}
                    S${targetPoint.x},${midY2} ${targetPoint.x},${targetPoint.y}`;
          }
        }
        
        // Store the path points for label positioning
        d.pathPoints = {
          source: sourcePoint,
          target: targetPoint,
          isHorizontal: Math.abs(sourcePoint.x - targetPoint.x) > Math.abs(sourcePoint.y - targetPoint.y)
        };
        
        return path;
      } catch (error) {
        console.error("Error generating link path:", error);
        return '';
      }
    });
    
    // Update label positions on the links
    labelElements.each(function(d) {
      try {
        if (!d.pathPoints) {
          return;
        }
        
        const { source, target } = d.pathPoints;
        const labelEl = d3.select(this);
        
        // Get nodes from source and target IDs
        const sourceNode = nodeMap.get(d.from);
        const targetNode = nodeMap.get(d.to);
        
        // Skip if nodes not found
        if (!sourceNode || !targetNode) return;
        
        // Detect if this is a root connection
        const isRootConnection = (d.from === rootSubject || d.to === rootSubject);
        const isFromRoot = d.from === rootSubject;
        
        // Calculate the distance between nodes
        const dx = target.x - source.x;
        const dy = target.y - source.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        // Normalize the direction vector
        const nx = dx / distance;
        const ny = dy / distance;
        
        // Create perpendicular vector for offset
        const px = -ny;
        const py = nx;
        
        // Get actual path element for this edge to find points along the path
        const pathElement = linkElements.filter(e => e.from === d.from && e.to === d.to).node();
        let labelX, labelY;
        
        if (pathElement) {
          try {
            // Get the total length of the path
            const pathLength = pathElement.getTotalLength();
            
            // Position the label at a specific point along the path
            // Root connections might need different positioning
            let pathPosition;
            
            if (isRootConnection) {
              pathPosition = isFromRoot ? 0.4 : 0.6; // Position along the path
            } else {
              pathPosition = 0.5; // Middle of the path for non-root connections
            }
            
            // Get the point at the desired position along the path
            const point = pathElement.getPointAtLength(pathLength * pathPosition);
            labelX = point.x;
            labelY = point.y;
            
            // Create a unique identifier for this edge to ensure consistent offsets
            const edgeId = `${d.from}-${d.to}`;
            // Create a hash from the edge ID to get a deterministic but varied offset
            const hash = Math.abs(edgeId.split('').reduce((a, b) => {
              a = ((a << 5) - a) + b.charCodeAt(0);
              return a & a;
            }, 0));
            
            // For curves, we might need to adjust the perpendicular offset
            // Get points slightly before and after the current point to determine the tangent
            const pointBefore = pathElement.getPointAtLength(Math.max(0, pathLength * pathPosition - 10));
            const pointAfter = pathElement.getPointAtLength(Math.min(pathLength, pathLength * pathPosition + 10));
            
            // Calculate the tangent vector at this point
            const tangentX = pointAfter.x - pointBefore.x;
            const tangentY = pointAfter.y - pointBefore.y;
            const tangentLength = Math.sqrt(tangentX * tangentX + tangentY * tangentY);
            
            // Normalize the tangent vector
            const tnx = tangentX / tangentLength;
            const tny = tangentY / tangentLength;
            
            // Calculate the perpendicular vector to the tangent
            const tpx = -tny;
            const tpy = tnx;
            
            // Apply a small perpendicular offset to ensure text is on the line but visible
            const perpOffset = 15 + (hash % 10); // Smaller offset - just enough to not overlap the line
            
            // Use a deterministic but varied sign for the offset
            const sign = ((hash % 2) * 2 - 1); // Either 1 or -1
            labelX += tpx * perpOffset * sign;
            labelY += tpy * perpOffset * sign;
          } catch (e) {
            console.warn("Error positioning label on path:", e);
            
            // Fallback to simple midpoint positioning
            labelX = source.x + dx * 0.5;
            labelY = source.y + dy * 0.5;
          }
        } else {
          // Fallback if path element not found
          console.warn("Path element not found for label positioning");
          
          // Position at midpoint with offset
          labelX = source.x + dx * 0.5;
          labelY = source.y + dy * 0.5;
        }
        
        // Get text elements to calculate size
        const textElements = labelEl.selectAll('text.link-label');
        
        if (textElements.size() > 0) {
          let labelWidth = 0;
          let labelHeight = 0;
          
          // Calculate total width and height based on all text elements
          textElements.each(function() {
            try {
              const bbox = this.getBBox();
              labelWidth = Math.max(labelWidth, bbox.width);
              labelHeight += bbox.height;
            } catch (e) {
              console.log("Error getting text bounding box", e);
            }
          });
          
          // Add more padding
          labelWidth += 30;
          labelHeight += 16;
          
          // Update background rectangle size
          labelEl.select('rect.label-bg')
            .attr('width', labelWidth)
            .attr('height', labelHeight)
            .attr('x', -labelWidth / 2)
            .attr('y', -labelHeight / 2);
          
          // Update the text position to match the background
          labelEl.attr('transform', `translate(${labelX},${labelY})`);
          
          // Store the position for use in interactions
          d.labelX = labelX;
          d.labelY = labelY;
        }
      } catch (error) {
        console.error("Error positioning label:", error);
      }
    });
  } catch (error) {
    console.error("Error in tick function:", error);
  }
}

// Function to prevent label overlaps with nodes and other labels
function preventLabelOverlaps() {
  try {
    // First collect all node rectangles for overlap checking
    const nodeRects = [];
    nodeElements.each(function(d) {
      nodeRects.push({
        x: d.x - getNodeWidth(d) / 2,
        y: d.y - getNodeHeight(d) / 2,
        width: getNodeWidth(d),
        height: getNodeHeight(d),
        id: d.id,
        type: 'node',
        center: { x: d.x, y: d.y }
      });
    });
    
    // Collect all label rectangles
    const labelRects = [];
    labelElements.each(function(d) {
      const labelGroup = d3.select(this);
      const labelBg = labelGroup.select('.label-bg');
      
      // Skip if no background element
      if (labelBg.empty()) return;
      
      // Get the label's bounding box
      const labelBBox = labelBg.node().getBBox();
      if (!labelBBox) return;
      
      // Current label position
      const labelX = d.labelX || 0;
      const labelY = d.labelY || 0;
      
      // Get source and target nodes for this edge
      const sourceNode = nodeMap.get(d.from);
      const targetNode = nodeMap.get(d.to);
      
      if (!sourceNode || !targetNode) return;
      
      labelRects.push({
        x: labelX - labelBBox.width / 2,
        y: labelY - labelBBox.height / 2,
        width: labelBBox.width,
        height: labelBBox.height,
        edge: d,
        group: labelGroup,
        originalX: labelX,
        originalY: labelY,
        type: 'label',
        sourceNode: sourceNode,
        targetNode: targetNode,
        center: { x: labelX, y: labelY }
      });
    });
    
    // Process each label to avoid overlaps
    for (let i = 0; i < labelRects.length; i++) {
      const labelRect = labelRects[i];
      let hasOverlap = true;
      let attempts = 0;
      const maxAttempts = 10; // Limit repositioning attempts
      
      // Try to find a position without overlaps
      while (hasOverlap && attempts < maxAttempts) {
        hasOverlap = false;
        attempts++;
        
        // Check for overlaps with nodes
        for (const nodeRect of nodeRects) {
          if (rectsOverlap(labelRect, nodeRect)) {
            hasOverlap = true;
            
            // Try to move the label away from the node
            repositionLabelAwayFromRect(labelRect, nodeRect);
            break;
          }
        }
        
        // If no node overlaps, check for overlaps with other labels
        if (!hasOverlap) {
          for (let j = 0; j < i; j++) {
            if (rectsOverlap(labelRect, labelRects[j])) {
              hasOverlap = true;
              
              // Try to move the label away from the other label
              repositionLabelAwayFromRect(labelRect, labelRects[j]);
              break;
            }
          }
        }
        
        // If we still have overlaps after several attempts, try a more drastic approach
        if (hasOverlap && attempts >= 5) {
          // Try positioning at different angles around the midpoint between source and target
          const sourceCenter = labelRect.sourceNode;
          const targetCenter = labelRect.targetNode;
          
          if (sourceCenter && targetCenter) {
            const midX = (sourceCenter.x + targetCenter.x) / 2;
            const midY = (sourceCenter.y + targetCenter.y) / 2;
            
            // Calculate distance to place label
            const distance = Math.max(labelRect.width, labelRect.height) * 1.5;
            
            // Try different angles
            const angle = (Math.PI * 2 * attempts) / maxAttempts;
            labelRect.x = midX + Math.cos(angle) * distance - labelRect.width / 2;
            labelRect.y = midY + Math.sin(angle) * distance - labelRect.height / 2;
          }
        }
      }
      
      // Update the label position
      const newX = labelRect.x + labelRect.width/2;
      const newY = labelRect.y + labelRect.height/2;
      
      labelRect.group.attr('transform', `translate(${newX}, ${newY})`);
      
      // Update stored position for future reference
      labelRect.edge.labelX = newX;
      labelRect.edge.labelY = newY;
    }
  } catch (error) {
    console.error("Error in preventLabelOverlaps:", error);
  }
}

// Helper function to check if two rectangles overlap
function rectsOverlap(rect1, rect2) {
  // Add a buffer zone to ensure labels don't touch
  const buffer = 25; // Increased buffer
  
  return !(
    rect1.x + rect1.width + buffer < rect2.x ||
    rect2.x + rect2.width + buffer < rect1.x ||
    rect1.y + rect1.height + buffer < rect2.y ||
    rect2.y + rect2.height + buffer < rect1.y
  );
}

// Helper function to reposition a label away from an overlapping rectangle
function repositionLabelAwayFromRect(labelRect, overlapRect) {
  // Calculate centers
  const labelCenterX = labelRect.x + labelRect.width / 2;
  const labelCenterY = labelRect.y + labelRect.height / 2;
  const rectCenterX = overlapRect.x + overlapRect.width / 2;
  const rectCenterY = overlapRect.y + overlapRect.height / 2;
  
  // Calculate direction vector from overlapping rect to label
  const dirX = labelCenterX - rectCenterX;
  const dirY = labelCenterY - rectCenterY;
  
  // Normalize direction vector
  const length = Math.sqrt(dirX * dirX + dirY * dirY);
  const normDirX = length > 0 ? dirX / length : 0;
  const normDirY = length > 0 ? dirY / length : 1; // Default to moving down if centers are the same
  
  // Calculate minimum distance needed to avoid overlap
  const minDistX = (labelRect.width + overlapRect.width) / 2;
  const minDistY = (labelRect.height + overlapRect.height) / 2;
  
  // Calculate the overlap amount
  const overlapX = minDistX - Math.abs(labelCenterX - rectCenterX);
  const overlapY = minDistY - Math.abs(labelCenterY - rectCenterY);
  
  // Add a larger buffer to ensure no overlap
  const buffer = 30; // Increased buffer
  
  // Move in the direction with the least overlap, but with a minimum movement
  const moveDistance = Math.max(Math.min(overlapX, overlapY) + buffer, 40); // Increased minimum distance
  
  if (overlapX < overlapY) {
    // Move horizontally
    labelRect.x += moveDistance * Math.sign(normDirX);
  } else {
    // Move vertically
    labelRect.y += moveDistance * Math.sign(normDirY);
  }
}

// Helper function to calculate the overlap area between two rectangles
function calculateOverlapArea(rect1, rect2) {
  // Calculate the overlap along the x-axis
  const overlapX = Math.max(0, 
    Math.min(rect1.x + rect1.width, rect2.x + rect2.width) - 
    Math.max(rect1.x, rect2.x)
  );
  
  // Calculate the overlap along the y-axis
  const overlapY = Math.max(0, 
    Math.min(rect1.y + rect1.height, rect2.y + rect2.height) - 
    Math.max(rect1.y, rect2.y)
  );
  
  // The overlap area is the product of the x and y overlaps
  return overlapX * overlapY;
}

// Helper function to find intersection point of a line with a rectangle
function findIntersectionPoint(x1, y1, x2, y2, rectX, rectY, rectWidth, rectHeight) {
  // Line equation: y = mx + b
  const dx = x2 - x1;
  const dy = y2 - y1;
  
  // Handle vertical line
  if (Math.abs(dx) < 0.001) {
    // Check if the line intersects the top or bottom of the rectangle
    if (x1 >= rectX && x1 <= rectX + rectWidth) {
      if (y1 < y2) { // Line going down
        return { x: x1, y: rectY };
      } else { // Line going up
        return { x: x1, y: rectY + rectHeight };
      }
    }
    return null;
  }
  
  // Handle horizontal line
  if (Math.abs(dy) < 0.001) {
    // Check if the line intersects the left or right of the rectangle
    if (y1 >= rectY && y1 <= rectY + rectHeight) {
      if (x1 < x2) { // Line going right
        return { x: rectX + rectWidth, y: y1 };
      } else { // Line going left
        return { x: rectX, y: y1 };
      }
    }
    return null;
  }
  
  // Calculate slope and y-intercept
  const m = dy / dx;
  const b = y1 - m * x1;
  
  // Check intersection with each edge of the rectangle
  const intersections = [];
  
  // Top edge: y = rectY
  const topX = (rectY - b) / m;
  if (topX >= rectX && topX <= rectX + rectWidth) {
    intersections.push({ x: topX, y: rectY, dist: Math.hypot(topX - x1, rectY - y1) });
  }
  
  // Bottom edge: y = rectY + rectHeight
  const bottomX = (rectY + rectHeight - b) / m;
  if (bottomX >= rectX && bottomX <= rectX + rectWidth) {
    intersections.push({ x: bottomX, y: rectY + rectHeight, dist: Math.hypot(bottomX - x1, rectY + rectHeight - y1) });
  }
  
  // Left edge: x = rectX
  const leftY = m * rectX + b;
  if (leftY >= rectY && leftY <= rectY + rectHeight) {
    intersections.push({ x: rectX, y: leftY, dist: Math.hypot(rectX - x1, leftY - y1) });
  }
  
  // Right edge: x = rectX + rectWidth
  const rightY = m * (rectX + rectWidth) + b;
  if (rightY >= rectY && rightY <= rectY + rectHeight) {
    intersections.push({ x: rectX + rectWidth, y: rightY, dist: Math.hypot(rectX + rectWidth - x1, rightY - y1) });
  }
  
  // Find the closest intersection point in the direction of the line
  let closestPoint = null;
  let minDist = Infinity;
  
  for (const point of intersections) {
    // Check if the point is in the direction of the line
    const dotProduct = (point.x - x1) * (x2 - x1) + (point.y - y1) * (y2 - y1);
    if (dotProduct > 0) {
      if (point.dist < minDist) {
        minDist = point.dist;
        closestPoint = point;
      }
    }
  }
  
  return closestPoint;
}

// Helper function to get node width
function getNodeWidth(node) {
  // Default width if not calculated yet
  if (!node._width) {
    // Base width on text length
    const textLength = node.id ? node.id.length : 10;
    const bulletInfo = node.bulletInfo || {};
    const bullet1 = bulletInfo.bullet_point1 || '';
    const bullet2 = bulletInfo.bullet_point2 || '';
    
    // Use consistent padding for all nodes
    const padding = 12;
    
    // If there are no bullet points, use a smaller width
    if (bullet1.length === 0 && bullet2.length === 0) {
      node._width = Math.max(textLength * 8 + padding * 2, 120);
      return node._width;
    }
    
    // For nodes with descriptions, calculate width based on content
    // Find the longest line in the bullets
    const longestBullet = bullet1.length > bullet2.length ? bullet1 : bullet2;
    
    // Estimate how many characters we can fit per line
    // Use a smaller character width to fit more text per line
    const charWidth = 6.5; // Pixels per character (reduced to fit more text)
    
    // Calculate a width that will fit approximately 40-50 chars per line
    // This ensures text fills the box better
    const targetCharsPerLine = 45;
    const contentBasedWidth = Math.min(
      Math.max(longestBullet.length, textLength * 1.5) * charWidth + padding * 2,
      targetCharsPerLine * charWidth + padding * 2
    );
    
    node._width = Math.max(contentBasedWidth, 220);
  }
  return node._width;
}

// Helper function to get node height
function getNodeHeight(node) {
  // Default height if not calculated yet
  if (!node._height) {
    // Base height on number of text lines
    const bulletInfo = node.bulletInfo || {};
    const bullet1 = bulletInfo.bullet_point1 || '';
    const bullet2 = bulletInfo.bullet_point2 || '';
    
    // Use consistent padding (12px) for top, sides, and bottom
    const padding = 12;
    
    // If there are no bullet points, use a smaller height but maintain padding
    if (bullet1.length === 0 && bullet2.length === 0) {
      node._height = padding + 18 + padding; // Top padding + title height + bottom padding
      return node._height;
    }
    
    // Get node width to calculate how many lines we'll need
    const nodeWidth = getNodeWidth(node);
    const charsPerLine = Math.floor((nodeWidth - padding * 2) / 6.5); // Characters per line
    
    // Count lines after wrapping
    const wrappedBullet1 = wrapText(bullet1, charsPerLine);
    const wrappedBullet2 = wrapText(bullet2, charsPerLine);
    
    const bulletLines1 = wrappedBullet1.length;
    const bulletLines2 = wrappedBullet2.length;
    
    // Calculate height based on number of lines
    // Top padding + title height + bullet points + bottom padding
    node._height = padding + 18 + (bulletLines1 + bulletLines2) * 18 + padding;
    
    // Add small padding between bullet points if both exist
    if (bulletLines1 > 0 && bulletLines2 > 0) {
      node._height += 5;
    }
    
    // Ensure minimum height
    node._height = Math.max(node._height, 60);
  }
  return node._height;
}

// Helper function to wrap text to a specified width
function wrapText(text, maxChars) {
  if (!text) return [];
  
  const words = text.split(' ');
  const lines = [];
  let currentLine = '';
  
  words.forEach(word => {
    // If the word itself is longer than maxChars, we need to break it
    if (word.length > maxChars) {
      // First add any current line content
      if (currentLine) {
        lines.push(currentLine);
        currentLine = '';
      }
      
      // Then break the long word
      let i = 0;
      while (i < word.length) {
        lines.push(word.substr(i, maxChars));
        i += maxChars;
      }
      return;
    }
    
    const testLine = currentLine ? `${currentLine} ${word}` : word;
    if (testLine.length <= maxChars) {
      currentLine = testLine;
    } else {
      lines.push(currentLine);
      currentLine = word;
    }
  });
  
  if (currentLine) {
    lines.push(currentLine);
  }
  
  return lines;
}

// Drag functions for nodes
function dragStarted(event, d) {
  if (!event.active) simulation.alphaTarget(0.3).restart();
  d.fx = d.x;
  d.fy = d.y;
  d3.select(this).select('rect').style('cursor', 'grabbing');
}

function dragged(event, d) {
  d.fx = event.x;
  d.fy = event.y;
}

function dragEnded(event, d) {
  if (!event.active) simulation.alphaTarget(0);
  // Keep root node fixed, release others
  if (d.id !== rootSubject) {
    d.fx = null;
    d.fy = null;
  }
  d3.select(this).select('rect').style('cursor', 'grab');
}

// Function to zoom to fit all nodes
function zoomToFitAll() {
  // Get the bounds of all nodes
  let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
  
  nodeElements.each(function(d) {
    const width = getNodeWidth(d);
    const height = getNodeHeight(d);
    
    minX = Math.min(minX, d.x - width/2);
    minY = Math.min(minY, d.y - height/2);
    maxX = Math.max(maxX, d.x + width/2);
    maxY = Math.max(maxY, d.y + height/2);
  });
  
  // Add padding
  const padding = 50;
  minX -= padding;
  minY -= padding;
  maxX += padding;
  maxY += padding;
  
  // Calculate the scale and translate to fit all nodes
  const graphWidth = maxX - minX;
  const graphHeight = maxY - minY;
  const scale = Math.min(width / graphWidth, height / graphHeight, 1);
  
  const translateX = width/2 - (minX + maxX)/2 * scale;
  const translateY = height/2 - (minY + maxY)/2 * scale;
  
  // Apply the zoom transform
  d3.select('#graph').transition().duration(750).call(
    zoom.transform,
    d3.zoomIdentity.translate(translateX, translateY).scale(scale)
  );
}

function buildGraph(subject, filterKeywords = []) {
  // Update page title with subject name
  try {
    const subjectName = nameFromEntityId(subject);
    document.title = `${subjectName} - People Relations`;
    $('#graphTitle').text(`${subjectName} - Relationship Graph`);
  } catch (e) {
    document.title = "People Relations";
    $('#graphTitle').text("Relationship Graph");
  }
  
  // Update loading overlay text
  $('#loading-text').text('Preparing graph data...');
  $('#loading').show(); // Ensure loading overlay is visible
  
  // Show loading indicator
  $('#loading-indicator').show();
  
  // Start fetch process
  const relationsZip = `../data/${subject}.zip`;
  // ... existing code ...
}

// Helper function to determine the "layer" of a node based on distance from root
function getNodeLayer(nodeId, edgesParam) {
  // Use provided edges parameter or fall back to global edges
  const edgesToUse = edgesParam || window.edges;
  
  if (nodeId === rootSubject) {
    return 0; // Root node is layer 0
  }
  
  // Check if directly connected to root
  const isDirectlyConnected = edgesToUse.some(
    edge => (edge.from === rootSubject && edge.to === nodeId) || 
            (edge.to === rootSubject && edge.from === nodeId)
  );
  
  if (isDirectlyConnected) {
    return 1; // Directly connected to root is layer 1
  }
  
  // Get nodes directly connected to root
  const connectedToRoot = edgesToUse.filter(
    edge => edge.from === rootSubject || edge.to === rootSubject
  ).map(edge => edge.from === rootSubject ? edge.to : edge.from);
  
  // Check if connected to a node that's connected to root
  const isTwoStepsAway = edgesToUse.some(
    edge => (connectedToRoot.includes(edge.from) && edge.to === nodeId) || 
            (connectedToRoot.includes(edge.to) && edge.from === nodeId)
  );
  
  if (isTwoStepsAway) {
    return 2; // Two steps away from root is layer 2
  }
  
  return 3; // Everything else is layer 3 or beyond
}


</script>
</body>
</html>
